{"repo":"Kaushik4141/InnovateHubCEC","url":"https://github.com/Kaushik4141/InnovateHubCEC","branch":"main","file_tree":[".gitignore","README.md","backend/.dockerignore","backend/Dockerfile","backend/package-lock.json","backend/package.json","backend/public/default_avatar.png","backend/public/default_coverimage.jpg","backend/public/temp/.gitkeep","backend/src/app.js","backend/src/chatbot/chatbot.py","backend/src/chatbot/chatflask.py","backend/src/chatbot/requirements.txt","backend/src/constants.js","backend/src/controllers/activity.controller.js","backend/src/controllers/chat.controller.js","backend/src/controllers/competition.controller.js","backend/src/controllers/contest.controller.js","backend/src/controllers/github.controller.js","backend/src/controllers/githubleaderboard.controller.js","backend/src/controllers/leetcodeleaderboard.controller.js","backend/src/controllers/linkedinpost.controller.js","backend/src/controllers/mentor.controller.js","backend/src/controllers/opportunity.controller.js","backend/src/controllers/post.controller.js","backend/src/controllers/stats.controller.js","backend/src/controllers/team.controller.js","backend/src/controllers/user.controller.js","backend/src/db/server.js","backend/src/job_scarpper/format.py","backend/src/job_scarpper/job_matching.py","backend/src/job_scarpper/job_scarpper.py","backend/src/job_scarpper/jobs_output.json","backend/src/job_scarpper/resume.pdf","backend/src/loadENV.js","backend/src/middlewares/auth.middleware.js","backend/src/middlewares/cache.middleware.js","backend/src/middlewares/multer.middleware.js","backend/src/models/chatroom.model.js","backend/src/models/competition.model.js","backend/src/models/contest.model.js","backend/src/models/follower.model.js","backend/src/models/github.model.js","backend/src/models/leetcode.model.js","backend/src/models/linkedinpost.model.js","backend/src/models/mentor.model.js","backend/src/models/mentorApplication.model.js","backend/src/models/message.model.js","backend/src/models/opportunity.model.js","backend/src/models/post.model.js","backend/src/models/problem.model.js","backend/src/models/submission.model.js","backend/src/models/team.model.js","backend/src/models/user.model.js","backend/src/reccomondation system/reccomondatio.py","backend/src/routes/activity.routes.js","backend/src/routes/chat.router.js","backend/src/routes/chatbot.router.js","backend/src/routes/competition.router.js","backend/src/routes/contest.router.js","backend/src/routes/leaderboard.router.js","backend/src/routes/mentor.router.js","backend/src/routes/opportunity.router.js","backend/src/routes/post.router.js","backend/src/routes/stats.router.js","backend/src/routes/team.routes.js","backend/src/routes/user.router.js","backend/src/server.js","backend/src/services/judge0.service.js","backend/src/socket.js","backend/src/utils/apierrorhandler.js","backend/src/utils/apiresponsehandler.js","backend/src/utils/asynchandler.js","backend/src/utils/cloudinary.js","backend/src/utils/leetcodeScheduler.js","backend/src/youtube/youtube.py","frontend/eslint.config.js","frontend/index.html","frontend/package-lock.json","frontend/package.json","frontend/postcss.config.js","frontend/public/04.png","frontend/public/Achieve.png","frontend/public/Empower.png","frontend/public/Excel.png","frontend/public/Explore.png","frontend/public/Gemini_Generated_Image_rxkan0rxkan0rxka (1).png","frontend/public/Innovate.png","frontend/public/blackboard.png","frontend/public/build.png","frontend/public/chat.mp4","frontend/public/codingcontest.png","frontend/public/collaborate.png","frontend/public/contest.mp4","frontend/public/dashboard.mp4","frontend/public/desktop.ini","frontend/public/dronecec.mp4","frontend/public/express.png","frontend/public/google06e8656ad42c75d4.html","frontend/public/group-disc.jpg","frontend/public/gsap.png","frontend/public/hackathon.png","frontend/public/inspire.png","frontend/public/job.mp4","frontend/public/judge0.png","frontend/public/landingpage.webp","frontend/public/leaderboard.mp4","frontend/public/lenis.gif","frontend/public/loa.gif","frontend/public/logo.png","frontend/public/logo1.png","frontend/public/mongo.png","frontend/public/mongoDB.png","frontend/public/programing.png","frontend/public/project showcase.png","frontend/public/realtimechat.png","frontend/public/robots.txt","frontend/public/script.js","frontend/public/showreel.mp4","frontend/public/sitemap.xml","frontend/public/skill.png","frontend/public/software-engineer-resume-example.pdf","frontend/public/style.css","frontend/public/tailwind.png","frontend/public/testimonial.png","frontend/public/testinomial.png","frontend/public/victory.png","frontend/src/App.tsx","frontend/src/components/Admin.tsx","frontend/src/components/AdminCompetitions.tsx","frontend/src/components/AdminContestProblems.tsx","frontend/src/components/AdminContests.tsx","frontend/src/components/CallToAction.tsx","frontend/src/components/Chat.tsx","frontend/src/components/CompetitionParticipants.tsx","frontend/src/components/Competitions.tsx","frontend/src/components/ContestLeaderboard.tsx","frontend/src/components/ContestView.tsx","frontend/src/components/Contests.tsx","frontend/src/components/Dashboard.tsx","frontend/src/components/EditProfileModal.tsx","frontend/src/components/FeaturedProjects.tsx","frontend/src/components/Feed.tsx","frontend/src/components/FloatingDock.tsx","frontend/src/components/Footer.tsx","frontend/src/components/Header.tsx","frontend/src/components/Jobs.tsx","frontend/src/components/LandingPage.tsx","frontend/src/components/Leaderboard.tsx","frontend/src/components/LinkedinPostFeed.tsx","frontend/src/components/Login.tsx","frontend/src/components/MediaLightbox.tsx","frontend/src/components/MentorApply.tsx","frontend/src/components/Mentors.tsx","frontend/src/components/MentorsList.tsx","frontend/src/components/Messages.tsx","frontend/src/components/Network.tsx","frontend/src/components/Notifications.tsx","frontend/src/components/Onboarding.tsx","frontend/src/components/Profile.tsx","frontend/src/components/Projects.tsx","frontend/src/components/ShareModal.tsx","frontend/src/components/Sidebar.tsx","frontend/src/components/SkillDomains.tsx","frontend/src/components/SolveProblem.tsx","frontend/src/components/Team.tsx","frontend/src/components/TeamEvent.tsx","frontend/src/components/TopMentors.tsx","frontend/src/components/TourGuide.tsx","frontend/src/components/UserProfileView.tsx","frontend/src/components/UserSearchModal.tsx","frontend/src/components/addpost.tsx","frontend/src/components/chatbot.tsx","frontend/src/components/chatbotFab.tsx","frontend/src/components/feedbackform.tsx","frontend/src/components/landingpage/About.tsx","frontend/src/components/landingpage/Blogs.tsx","frontend/src/components/landingpage/BrandPartners.tsx","frontend/src/components/landingpage/ConceptCards.tsx","frontend/src/components/landingpage/FAQ.tsx","frontend/src/components/landingpage/Footer.tsx","frontend/src/components/landingpage/Hero.tsx","frontend/src/components/landingpage/Navigation.tsx","frontend/src/components/landingpage/Portfolio.tsx","frontend/src/components/landingpage/ProsBento.tsx","frontend/src/components/landingpage/ScrollButton.tsx","frontend/src/components/landingpage/Showreel.tsx","frontend/src/components/landingpage/Testimonials.tsx","frontend/src/components/landingpage/TextImageMarquee.tsx","frontend/src/components/landingpage/VideoPopup.tsx","frontend/src/components/landingpage/contributors.tsx","frontend/src/components/landingpage/mainlanding.tsx","frontend/src/components/landingpage/styles/main.css","frontend/src/components/loading.tsx","frontend/src/components/register.tsx","frontend/src/context/ChatContext.tsx","frontend/src/cookiescheker.ts","frontend/src/hooks/useTour.ts","frontend/src/index.css","frontend/src/main.tsx","frontend/src/services/api.ts","frontend/src/services/chatApi.ts","frontend/src/services/competitionApi.ts","frontend/src/services/contestApi.ts","frontend/src/services/judge0Langs.ts","frontend/src/services/networkApi.ts","frontend/src/services/notificationsApi.ts","frontend/src/services/notifier.ts","frontend/src/services/opportunityApi.ts","frontend/src/services/postApi.ts","frontend/src/services/teamApi.ts","frontend/src/services/userApi.ts","frontend/src/vite-env.d.ts","frontend/tailwind.config.js","frontend/tsconfig.app.json","frontend/tsconfig.json","frontend/tsconfig.node.json","frontend/vercel.json","frontend/views/index.html","frontend/vite.config.ts","render.yaml"],"target_directory_files":["backend/.dockerignore","backend/Dockerfile","backend/package-lock.json","backend/package.json","backend/public/default_avatar.png","backend/public/default_coverimage.jpg","backend/public/temp/.gitkeep","backend/src/app.js","backend/src/chatbot/chatbot.py","backend/src/chatbot/chatflask.py","backend/src/chatbot/requirements.txt","backend/src/constants.js","backend/src/controllers/activity.controller.js","backend/src/controllers/chat.controller.js","backend/src/controllers/competition.controller.js","backend/src/controllers/contest.controller.js","backend/src/controllers/github.controller.js","backend/src/controllers/githubleaderboard.controller.js","backend/src/controllers/leetcodeleaderboard.controller.js","backend/src/controllers/linkedinpost.controller.js","backend/src/controllers/mentor.controller.js","backend/src/controllers/opportunity.controller.js","backend/src/controllers/post.controller.js","backend/src/controllers/stats.controller.js","backend/src/controllers/team.controller.js","backend/src/controllers/user.controller.js","backend/src/db/server.js","backend/src/job_scarpper/format.py","backend/src/job_scarpper/job_matching.py","backend/src/job_scarpper/job_scarpper.py","backend/src/job_scarpper/jobs_output.json","backend/src/job_scarpper/resume.pdf","backend/src/loadENV.js","backend/src/middlewares/auth.middleware.js","backend/src/middlewares/cache.middleware.js","backend/src/middlewares/multer.middleware.js","backend/src/models/chatroom.model.js","backend/src/models/competition.model.js","backend/src/models/contest.model.js","backend/src/models/follower.model.js","backend/src/models/github.model.js","backend/src/models/leetcode.model.js","backend/src/models/linkedinpost.model.js","backend/src/models/mentor.model.js","backend/src/models/mentorApplication.model.js","backend/src/models/message.model.js","backend/src/models/opportunity.model.js","backend/src/models/post.model.js","backend/src/models/problem.model.js","backend/src/models/submission.model.js","backend/src/models/team.model.js","backend/src/models/user.model.js","backend/src/reccomondation system/reccomondatio.py","backend/src/routes/activity.routes.js","backend/src/routes/chat.router.js","backend/src/routes/chatbot.router.js","backend/src/routes/competition.router.js","backend/src/routes/contest.router.js","backend/src/routes/leaderboard.router.js","backend/src/routes/mentor.router.js","backend/src/routes/opportunity.router.js","backend/src/routes/post.router.js","backend/src/routes/stats.router.js","backend/src/routes/team.routes.js","backend/src/routes/user.router.js","backend/src/server.js","backend/src/services/judge0.service.js","backend/src/socket.js","backend/src/utils/apierrorhandler.js","backend/src/utils/apiresponsehandler.js","backend/src/utils/asynchandler.js","backend/src/utils/cloudinary.js","backend/src/utils/leetcodeScheduler.js","backend/src/youtube/youtube.py","frontend/eslint.config.js","frontend/index.html","frontend/package-lock.json","frontend/package.json","frontend/postcss.config.js","frontend/public/04.png","frontend/public/Achieve.png","frontend/public/Empower.png","frontend/public/Excel.png","frontend/public/Explore.png","frontend/public/Gemini_Generated_Image_rxkan0rxkan0rxka (1).png","frontend/public/Innovate.png","frontend/public/blackboard.png","frontend/public/build.png","frontend/public/chat.mp4","frontend/public/codingcontest.png","frontend/public/collaborate.png","frontend/public/contest.mp4","frontend/public/dashboard.mp4","frontend/public/desktop.ini","frontend/public/dronecec.mp4","frontend/public/express.png","frontend/public/google06e8656ad42c75d4.html","frontend/public/group-disc.jpg","frontend/public/gsap.png","frontend/public/hackathon.png","frontend/public/inspire.png","frontend/public/job.mp4","frontend/public/judge0.png","frontend/public/landingpage.webp","frontend/public/leaderboard.mp4","frontend/public/lenis.gif","frontend/public/loa.gif","frontend/public/logo.png","frontend/public/logo1.png","frontend/public/mongo.png","frontend/public/mongoDB.png","frontend/public/programing.png","frontend/public/project showcase.png","frontend/public/realtimechat.png","frontend/public/robots.txt","frontend/public/script.js","frontend/public/showreel.mp4","frontend/public/sitemap.xml","frontend/public/skill.png","frontend/public/software-engineer-resume-example.pdf","frontend/public/style.css","frontend/public/tailwind.png","frontend/public/testimonial.png","frontend/public/testinomial.png","frontend/public/victory.png","frontend/src/App.tsx","frontend/src/components/Admin.tsx","frontend/src/components/AdminCompetitions.tsx","frontend/src/components/AdminContestProblems.tsx","frontend/src/components/AdminContests.tsx","frontend/src/components/CallToAction.tsx","frontend/src/components/Chat.tsx","frontend/src/components/CompetitionParticipants.tsx","frontend/src/components/Competitions.tsx","frontend/src/components/ContestLeaderboard.tsx","frontend/src/components/ContestView.tsx","frontend/src/components/Contests.tsx","frontend/src/components/Dashboard.tsx","frontend/src/components/EditProfileModal.tsx","frontend/src/components/FeaturedProjects.tsx","frontend/src/components/Feed.tsx","frontend/src/components/FloatingDock.tsx","frontend/src/components/Footer.tsx","frontend/src/components/Header.tsx","frontend/src/components/Jobs.tsx","frontend/src/components/LandingPage.tsx","frontend/src/components/Leaderboard.tsx","frontend/src/components/LinkedinPostFeed.tsx","frontend/src/components/Login.tsx","frontend/src/components/MediaLightbox.tsx","frontend/src/components/MentorApply.tsx","frontend/src/components/Mentors.tsx","frontend/src/components/MentorsList.tsx","frontend/src/components/Messages.tsx","frontend/src/components/Network.tsx","frontend/src/components/Notifications.tsx","frontend/src/components/Onboarding.tsx","frontend/src/components/Profile.tsx","frontend/src/components/Projects.tsx","frontend/src/components/ShareModal.tsx","frontend/src/components/Sidebar.tsx","frontend/src/components/SkillDomains.tsx","frontend/src/components/SolveProblem.tsx","frontend/src/components/Team.tsx","frontend/src/components/TeamEvent.tsx","frontend/src/components/TopMentors.tsx","frontend/src/components/TourGuide.tsx","frontend/src/components/UserProfileView.tsx","frontend/src/components/UserSearchModal.tsx","frontend/src/components/addpost.tsx","frontend/src/components/chatbot.tsx","frontend/src/components/chatbotFab.tsx","frontend/src/components/feedbackform.tsx","frontend/src/components/landingpage/About.tsx","frontend/src/components/landingpage/Blogs.tsx","frontend/src/components/landingpage/BrandPartners.tsx","frontend/src/components/landingpage/ConceptCards.tsx","frontend/src/components/landingpage/FAQ.tsx","frontend/src/components/landingpage/Footer.tsx","frontend/src/components/landingpage/Hero.tsx","frontend/src/components/landingpage/Navigation.tsx","frontend/src/components/landingpage/Portfolio.tsx","frontend/src/components/landingpage/ProsBento.tsx","frontend/src/components/landingpage/ScrollButton.tsx","frontend/src/components/landingpage/Showreel.tsx","frontend/src/components/landingpage/Testimonials.tsx","frontend/src/components/landingpage/TextImageMarquee.tsx","frontend/src/components/landingpage/VideoPopup.tsx","frontend/src/components/landingpage/contributors.tsx","frontend/src/components/landingpage/mainlanding.tsx","frontend/src/components/landingpage/styles/main.css","frontend/src/components/loading.tsx","frontend/src/components/register.tsx","frontend/src/context/ChatContext.tsx","frontend/src/cookiescheker.ts","frontend/src/hooks/useTour.ts","frontend/src/index.css","frontend/src/main.tsx","frontend/src/services/api.ts","frontend/src/services/chatApi.ts","frontend/src/services/competitionApi.ts","frontend/src/services/contestApi.ts","frontend/src/services/judge0Langs.ts","frontend/src/services/networkApi.ts","frontend/src/services/notificationsApi.ts","frontend/src/services/notifier.ts","frontend/src/services/opportunityApi.ts","frontend/src/services/postApi.ts","frontend/src/services/teamApi.ts","frontend/src/services/userApi.ts","frontend/src/vite-env.d.ts","frontend/tailwind.config.js","frontend/tsconfig.app.json","frontend/tsconfig.json","frontend/tsconfig.node.json","frontend/vercel.json","frontend/views/index.html","frontend/vite.config.ts"],"key_files":{"README.md":{"path":"README.md","content":"# InnovateHubCEC\n\nInnovateHubCEC is a dynamic platform designed for the students of Canara Engineering College (CEC). It serves as a central hub for students to showcase projects, share innovative ideas, and connect with peers and mentors across various technical domains. The platform fosters a culture of building and collaboration by providing tools for project visibility, skill-matching, and healthy competition through coding leaderboards.\n\n## Live Demo\n\nYou can access the live application here: **[https://innovatehubcec.vercel.app/](https://innovatehubcec.vercel.app/)**\n\n## Γ£¿ Key Features\n\n*   **Project Showcase:** Upload project details, descriptions, media (images/videos), and link to live demos and GitHub repositories.\n*   **Peer Networking:** Follow other students, get notified of their activities, and build a professional network within the campus community.\n*   **Real-time Chat:** Engage in discussions in public chat rooms (e.g., General, Projects) or have private one-on-one conversations with peers and mentors.\n*   **Coding Leaderboards:** Stay motivated with an integrated leaderboard system that tracks and ranks GitHub contributions and LeetCode problem-solving stats.\n*   **LinkedIn Integration:** Automatically fetch and display your latest LinkedIn posts on your feed to share professional updates with your network.\n*   **Comprehensive User Profiles:** Create detailed profiles with skills, certifications, projects, achievements, and links to external profiles like GitHub, LinkedIn, and LeetCode.\n\n## ≡ƒ¢á∩╕Å Tech Stack\n\n### Backend\n*   **Framework:** Node.js, Express.js\n*   **Database:** MongoDB with Mongoose\n*   **Authentication:** JSON Web Tokens (JWT)\n*   **Real-time Communication:** Socket.IO\n*   **File Storage:** Cloudinary for media uploads\n*   **Web Scraping:** Apify for LinkedIn post integration\n*   **Scheduling:** node-cron for updating leaderboard stats\n\n### Frontend\n*   **Framework/Library:** React with Vite\n*   **Language:** TypeScript\n*   **Styling:** Tailwind CSS\n*   **State Management:** React Context API\n*   **API Communication:** Axios\n*   **Real-time Communication:** Socket.IO Client\n\n## ≡ƒÜÇ Getting Started\n\nTo get a local copy up and running, follow these simple steps.\n\n### Prerequisites\n\n*   Node.js (v18 or higher)\n*   npm (or yarn/pnpm)\n*   MongoDB instance (local or Atlas)\n\n### Installation\n\n1.  **Clone the repository:**\n    ```sh\n    git clone https://github.com/kaushik4141/InnovateHubCEC.git\n    cd InnovateHubCEC\n    ```\n\n2.  **Set up the Backend:**\n    ```sh\n    cd backend\n    npm install\n    ```\n    Create a `.env` file in the `backend` directory and add the necessary environment variables (see `.env.example` section below).\n    ```sh\n    npm run dev\n    ```\n\n3.  **Set up the Frontend:**\n    ```sh\n    cd ../frontend\n    npm install\n    npm run dev\n    ```\n\nThe frontend will be available at `http://localhost:5173` (or another port if 5173 is busy) and the backend server will run on the port specified in your `.env` file (e.g., 8000).\n\n### Environment Variables\n\nCreate a `.env` file in the `backend` directory and add the following variables. Replace the placeholder values with your actual credentials.\n\n```env\n# Server Configuration\nPORT=8000\nCORS_ORIGIN=http://localhost:5173\n\n# MongoDB Connection\nMONGODB_URI=your_mongodb_connection_string\n\n# JWT Secrets\nACCESS_TOKEN_SECRET=your_access_token_secret\nACCESS_TOKEN_EXPIRY=1d\nREFRESH_TOKEN_SECRET=your_refresh_token_secret\nREFRESH_TOKEN_EXPIRY=10d\n\n# Cloudinary Credentials\nCLOUDINARY_CLOUD_NAME=your_cloudinary_cloud_name\nCLOUDINARY_API_KEY=your_cloudinary_api_key\nCLOUDINARY_API_SECRET=your_cloudinary_api_secret\n\n# Apify Credentials (for LinkedIn Scraping)\nAPIFY_TOKEN=your_apify_token\nAPIFY_ACTOR_ID=your_apify_actor_id\nAPIFY_DATASET_ID=your_apify_dataset_id\n```\n\n## ≡ƒôé Project Structure\n\nThe repository is organized as a monorepo with two main directories:\n\n*   `backend/`: Contains the Node.js/Express server.\n    *   `src/controllers/`: Logic for handling API requests.\n    *   `src/models/`: Mongoose schemas for the database.\n    *   `src/routes/`: API en"},"backend/.dockerignore":{"path":"backend/.dockerignore","content":"# Exclude dev and VCS files from Docker build context\nnode_modules\nnpm-debug.log*\nyarn-error.log*\n.pnpm-store\n\n# Local env and secrets\n.env\n.env.*\n\n# Editor/OS\n.vscode\n.idea\n.DS_Store\n\n# Tests and coverage\ncoverage\n*.spec.*\n*.test.*\n\n# Logs and caches\nlogs\n*.log\n.cache\n.tmp\n\n# Monorepo folders not needed for backend image\n../frontend\n/frontend\n\n# Git\n.git\n.gitignore\n\n# Build artifacts\nbuild\ndist\n"},"backend/Dockerfile":{"path":"backend/Dockerfile","content":"# Multi-stage Dockerfile for InnovateHubCEC backend\n# Stage 1: deps (install only once unless package-lock.json changes)\nFROM node:18-alpine AS deps\nWORKDIR /app\n# Install OS deps only if you later need the Python job scraper\n# RUN apk add --no-cache python3\nCOPY package*.json ./\nRUN npm ci --omit=dev\n\n# Stage 2: runner\nFROM node:18-alpine AS runner\nENV NODE_ENV=production\nWORKDIR /app\n\n# Copy node_modules from deps layer\nCOPY --from=deps /app/node_modules ./node_modules\n\n# Copy app source (keep this after deps to maximize cache hits)\nCOPY . .\n\n# Ensure the process runs as non-root\nUSER node\n\n# Render/containers will pass PORT; server reads process.env.PORT\nEXPOSE 8000\n\n# Start server\nCMD [\"node\", \"src/server.js\"]\n"},"backend/package-lock.json":{"path":"backend/package-lock.json","content":"{\n  \"name\": \"innovatehubcec\",\n  \"version\": \"1.0.0\",\n  \"lockfileVersion\": 3,\n  \"requires\": true,\n  \"packages\": {\n    \"\": {\n      \"name\": \"innovatehubcec\",\n      \"version\": \"1.0.0\",\n      \"license\": \"ISC\",\n      \"dependencies\": {\n        \"@monaco-editor/react\": \"^4.7.0\",\n        \"@xenova/transformers\": \"^2.17.2\",\n        \"axios\": \"^1.11.0\",\n        \"bcrypt\": \"^6.0.0\",\n        \"cheerio\": \"^1.1.2\",\n        \"cloudinary\": \"^2.7.0\",\n        \"cookie\": \"^1.0.2\",\n        \"cookie-parser\": \"^1.4.7\",\n        \"cookieparser\": \"^0.1.0\",\n        \"cors\": \"^2.8.5\",\n        \"dotenv\": \"^17.0.1\",\n        \"ejs\": \"^3.1.10\",\n        \"express\": \"^5.1.0\",\n        \"google-auth-library\": \"^10.2.1\",\n        \"jsonwebtoken\": \"^9.0.2\",\n        \"mongoose\": \"^8.16.1\",\n        \"mongoose-aggregate-paginate-v2\": \"^1.1.4\",\n        \"multer\": \"^2.0.1\",\n        \"node-cron\": \"^4.2.1\",\n        \"nodemailer\": \"^7.0.5\",\n        \"socket.io\": \"^4.8.1\"\n      }\n    },\n    \"node_modules/@huggingface/jinja\": {\n      \"version\": \"0.2.2\",\n      \"resolved\": \"https://registry.npmjs.org/@huggingface/jinja/-/jinja-0.2.2.tgz\",\n      \"integrity\": \"sha512-/KPde26khDUIPkTGU82jdtTW9UAuvUTumCAbFs/7giR0SxsvZC4hru51PBvpijH6BVkHcROcvZM/lpy5h1jRRA==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@monaco-editor/loader\": {\n      \"version\": \"1.5.0\",\n      \"resolved\": \"https://registry.npmjs.org/@monaco-editor/loader/-/loader-1.5.0.tgz\",\n      \"integrity\": \"sha512-hKoGSM+7aAc7eRTRjpqAZucPmoNOC4UUbknb/VNoTkEIkCPhqV8LfbsgM1webRM7S/z21eHEx9Fkwx8Z/C/+Xw==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"state-local\": \"^1.0.6\"\n      }\n    },\n    \"node_modules/@monaco-editor/react\": {\n      \"version\": \"4.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/@monaco-editor/react/-/react-4.7.0.tgz\",\n      \"integrity\": \"sha512-cyzXQCtO47ydzxpQtCGSQGOC8Gk3ZUeBXFAxD+CWXYFo5OqZyZUonFl0DwUlTyAfRHntBfw2p3w4s9R6oe1eCA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@monaco-editor/loader\": \"^1.5.0\"\n      },\n      \"peerDependencies\": {\n        \"monaco-editor\": \">= 0.25.0 < 1\",\n        \"react\": \"^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0\",\n        \"react-dom\": \"^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0\"\n      }\n    },\n    \"node_modules/@mongodb-js/saslprep\": {\n      \"version\": \"1.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/@mongodb-js/saslprep/-/saslprep-1.3.0.tgz\",\n      \"integrity\": \"sha512-zlayKCsIjYb7/IdfqxorK5+xUMyi4vOKcFy10wKJYc63NSdKI8mNME+uJqfatkPmOSMMUiojrL58IePKBm3gvQ==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"sparse-bitfield\": \"^3.0.3\"\n      }\n    },\n    \"node_modules/@protobufjs/aspromise\": {\n      \"version\": \"1.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/@protobufjs/aspromise/-/aspromise-1.1.2.tgz\",\n      \"integrity\": \"sha512-j+gKExEuLmKwvz3OgROXtrJ2UG2x8Ch2YZUxahh+s1F2HZ+wAceUNLkvy6zKCPVRkU++ZWQrdxsUeQXmcg4uoQ==\",\n      \"license\": \"BSD-3-Clause\"\n    },\n    \"node_modules/@protobufjs/base64\": {\n      \"version\": \"1.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/@protobufjs/base64/-/base64-1.1.2.tgz\",\n      \"integrity\": \"sha512-AZkcAA5vnN/v4PDqKyMR5lx7hZttPDgClv83E//FMNhR2TMcLUhfRUBHCmSl0oi9zMgDDqRUJkSxO3wm85+XLg==\",\n      \"license\": \"BSD-3-Clause\"\n    },\n    \"node_modules/@protobufjs/codegen\": {\n      \"version\": \"2.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/@protobufjs/codegen/-/codegen-2.0.4.tgz\",\n      \"integrity\": \"sha512-YyFaikqM5sH0ziFZCN3xDC7zeGaB/d0IUb9CATugHWbd1FRFwWwt4ld4OYMPWu5a3Xe01mGAULCdqhMlPl29Jg==\",\n      \"license\": \"BSD-3-Clause\"\n    },\n    \"node_modules/@protobufjs/eventemitter\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/@protobufjs/eventemitter/-/eventemitter-1.1.0.tgz\",\n      \"integrity\": \"sha512-j9ednRT81vYJ9OfVuXG6ERSTdEL1xVsNgqpkxMsbIabzSo3goCjDIveeGv5d03om39ML71RdmrGNjG5SReBP/Q==\",\n      \"license\": \"BSD-3-Clause\"\n    },\n    \"node_modules/@protobufjs/fetch\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/@protobufjs/fetch/-/fetch-1.1.0.tgz\",\n      \"integrity\": \"sha512-lljVXpqXebpsijW71PZaCYeIcE5on1w5DlQ"},"backend/package.json":{"path":"backend/package.json","content":"{\n  \"name\": \"innovatehubcec\",\n  \"version\": \"1.0.0\",\n  \"description\": \"≡ƒÜÇ InnovateHubCEC\\r InnovateHubCEC is an online platform built for students of CEC to showcase their projects, share their innovations, and connect with peers and seniors working in domains they are interested in.\",\n  \"main\": \"src/server.js\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"start\": \"node src/server.js\",\n    \"dev\": \"nodemon src/server.js\",\n    \"seed:problems\": \"node src/scripts/seedProblems.js\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"@monaco-editor/react\": \"^4.7.0\",\n    \"@xenova/transformers\": \"^2.17.2\",\n    \"axios\": \"^1.11.0\",\n    \"bcrypt\": \"^6.0.0\",\n    \"cheerio\": \"^1.1.2\",\n    \"cloudinary\": \"^2.7.0\",\n    \"cookie\": \"^1.0.2\",\n    \"cookie-parser\": \"^1.4.7\",\n    \"cookieparser\": \"^0.1.0\",\n    \"cors\": \"^2.8.5\",\n    \"dotenv\": \"^17.0.1\",\n    \"ejs\": \"^3.1.10\",\n    \"express\": \"^5.1.0\",\n    \"google-auth-library\": \"^10.2.1\",\n    \"jsonwebtoken\": \"^9.0.2\",\n    \"mongoose\": \"^8.16.1\",\n    \"mongoose-aggregate-paginate-v2\": \"^1.1.4\",\n    \"multer\": \"^2.0.1\",\n    \"node-cron\": \"^4.2.1\",\n    \"nodemailer\": \"^7.0.5\",\n    \"socket.io\": \"^4.8.1\"\n  }\n}\n"},"backend/src/app.js":{"path":"backend/src/app.js","content":"import express from 'express';\nimport cors from 'cors';\nimport  cookieParser from 'cookie-parser';\nimport { ApiError } from './utils/apierrorhandler.js';\nconst app = express();\napp.use(cors({\n    origin: process.env.CORS_ORIGIN,\n    credentials: true,\n    methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],\n    allowedHeaders: ['Content-Type', 'Authorization', 'Cookie'],\n    exposedHeaders: ['Set-Cookie']\n}))\napp.use(express.json({\n    limit: '1mb'\n}))\napp.use(express.urlencoded({\n    extended: true,\n    limit: '1mb'\n}))\napp.use(express.static('public', {\n  etag: true,\n  maxAge: '1d',\n  setHeaders: (res, path) => {\n    if (/\\.(?:png|jpe?g|gif|webp|svg|ico)$/i.test(path)) {\n      res.setHeader('Cache-Control', 'public, max-age=86400, immutable');\n    }\n  }\n}));\napp.use(cookieParser());\n\napp.use((req, res, next) => {\n  res.header('Access-Control-Allow-Credentials', 'true');\n  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization, Cookie');\n  res.header('Access-Control-Expose-Headers', 'Set-Cookie');\n  next();\n});\n \n//routes\nimport userRouter from './routes/user.router.js';\nimport postRouter from './routes/post.router.js';\nimport leaderboardRouter from './routes/leaderboard.router.js';\nimport chatRouter from './routes/chat.router.js';\nimport mentorRouter from './routes/mentor.router.js';\nimport opportunityRouter from './routes/opportunity.router.js';\nimport statsRouter from './routes/stats.router.js';\nimport  CompetitionRouter  from './routes/competition.router.js';\nimport contestRouter from './routes/contest.router.js';\nimport chatbotRouter from './routes/chatbot.router.js';\nimport teamRouter from './routes/team.routes.js';\nimport activityRouter from './routes/activity.routes.js';\n\nimport { startLeetcodeStatsScheduler } from './utils/leetcodeScheduler.js';\n\n//routes declaration\napp.use('/api/v1/users', userRouter);\napp.use('/api/v1/opportunities', opportunityRouter);\napp.use('/api/v1/posts', postRouter);\napp.use('/api/v1/leaderboard', leaderboardRouter);\napp.use('/api/v1/chat', chatRouter);\napp.use('/api/v1/mentors', mentorRouter);\napp.use('/api/v1/opportunities', opportunityRouter);\napp.use('/api/v1/stats', statsRouter);\napp.use('/api/v1/competitions', CompetitionRouter);\napp.use('/api/v1/contests', contestRouter);\napp.use('/api/v1/chatbot', chatbotRouter);\napp.use('/api/v1/teams', teamRouter);\napp.use('/api/v1/activity', activityRouter);\n\nstartLeetcodeStatsScheduler();\n\n//global error handler\napp.use((err, req, res, next) => {\n  const status = err?.statusCode || err?.status || 500;\n  const message = err?.message || 'Internal Server Error';\n  if (process.env.NODE_ENV !== 'production') {\n    console.error('[Error]', status, message);\n  }\n  if (err instanceof ApiError) {\n    return res.status(status).json({ success: false, message, data: err?.data || null });\n  }\n  return res.status(status).json({ success: false, message });\n});\n\napp\nexport { app }"},"backend/src/chatbot/chatbot.py":{"path":"backend/src/chatbot/chatbot.py","content":"from sentence_transformers import SentenceTransformer\nimport faiss\nimport numpy as np\nfrom spellchecker import SpellChecker\nimport re\nimport numpy as np\n\n\nquestions = [\n    # ≡ƒö╣ Project Showcase\n    \"How can I upload a project?\",\n    \"Can I add images or videos to my project?\",\n    \"How do I share my GitHub link?\",\n    \"Where will my projects be shown?\",\n    \"Can others see and comment on my projects?\",\n\n    # ≡ƒö╣ Peer Networking\n    \"How do I follow other students?\",\n    \"Will I get updates when someone posts a new project?\",\n    \"Can I unfollow someone later?\",\n    \"How do I build my network?\",\n\n    # ≡ƒö╣ Real-time Chat\n    \"How do I join a public chat room?\",\n    \"What chat rooms are available?\",\n    \"Can I message someone privately?\",\n    \"Is chat available on mobile?\",\n\n    # ≡ƒö╣ Coding Leaderboards\n    \"What is the leaderboard for?\",\n    \"How is ranking calculated?\",\n    \"Does it track GitHub activity?\",\n    \"Can I connect my LeetCode account?\",\n    \"How often is the leaderboard updated?\",\n\n    # ≡ƒö╣ LinkedIn Integration\n    \"How do I link my LinkedIn account?\",\n    \"Will my LinkedIn posts show automatically?\",\n    \"Can I remove my LinkedIn integration?\",\n\n    # ≡ƒö╣ User Profiles\n    \"How do I update my profile?\",\n    \"What details can I add to my profile?\",\n    \"Can I link my GitHub and LeetCode profiles?\",\n    \"Can I add certifications and skills to my profile?\",\n    \"Who can view my profile?\",\n\n    # ≡ƒö╣ General / Other\n    \"What is this website about?\",\n    \"Who is this website for?\",\n    \"Is there a free plan?\",\n    \"How do I contact support?\",\n    \"I forgot my password, what do I do?\",\n    \"Website not loading, what should I do?\",\n    \"Site looks different on mobile, is that normal?\"\n]\n\ndocuments = [\n    # ≡ƒö╣ Project Showcase\n    \"Go to your profile and click ΓÇÿAdd ProjectΓÇÖ to upload project details.\",\n    \"Yes, you can attach images, videos, and documents to showcase your project better.\",\n    \"When adding a project, you can paste your GitHub or live demo link.\",\n    \"Your projects will appear on your profile and in the project showcase section.\",\n    \"Yes, other students can view and interact with your projects.\",\n\n    # ≡ƒö╣ Peer Networking\n    \"Click the ΓÇÿFollowΓÇÖ button on a studentΓÇÖs profile to follow them.\",\n    \"Yes, youΓÇÖll be notified when someone you follow uploads a new project or update.\",\n    \"Yes, you can unfollow anytime from their profile.\",\n    \"Engage with projects, follow peers, and join chats to build your network.\",\n\n    # ≡ƒö╣ Real-time Chat\n    \"Go to the chat section and select the room you want to join.\",\n    \"Common chat rooms include General, Projects, and Help.\",\n    \"Yes, you can send private one-on-one messages.\",\n    \"Yes, the chat feature is available on both desktop and mobile.\",\n\n    # ≡ƒö╣ Coding Leaderboards\n    \"The leaderboard shows top performers based on coding activity.\",\n    \"Ranking is calculated from GitHub commits and LeetCode problems solved.\",\n    \"Yes, your GitHub contributions are tracked.\",\n    \"Yes, you can connect your LeetCode account from your profile settings.\",\n    \"The leaderboard is updated daily to reflect your progress.\",\n\n    # ≡ƒö╣ LinkedIn Integration\n    \"You can link your LinkedIn account from your profile settings.\",\n    \"Yes, your latest LinkedIn posts will automatically appear on your feed.\",\n    \"Yes, you can remove LinkedIn integration anytime from settings.\",\n\n    # ≡ƒö╣ User Profiles\n    \"Go to your profile page and click ΓÇÿEditΓÇÖ to update your details.\",\n    \"You can add skills, certifications, projects, achievements, and links to external profiles.\",\n    \"Yes, you can link GitHub, LinkedIn, and LeetCode accounts from your profile.\",\n    \"Yes, certifications and skills can be added under the profile section.\",\n    \"Your profile is visible to other students and mentors on the platform.\",\n\n    # ≡ƒö╣ General / Other\n    \"This platform helps students showcase projects, connect with peers, and grow professionally.\",\n    \"It is mainly designed for students who want to build their career profile and network.\",\n    \"Yes, we offer a free plan with limited features.\",\n    \"You can"},"backend/src/chatbot/chatflask.py":{"path":"backend/src/chatbot/chatflask.py","content":"\nfrom flask import Flask, request, jsonify\nfrom sentence_transformers import SentenceTransformer\nimport faiss\nimport numpy as np\nfrom spellchecker import SpellChecker\nimport re\nfrom flask_cors import CORS\nimport os\n\n# -------------------------------\n# 1. Questions & Answers\n# -------------------------------\nquestions = [\n    # ≡ƒö╣ Project Showcase\n    \"How can I upload a project?\",\n    \"Can I add images or videos to my project?\",\n    \"How do I share my GitHub link?\",\n    \"Where will my projects be shown?\",\n    \"Can others see and comment on my projects?\",\n\n    # ≡ƒö╣ Peer Networking\n    \"How do I follow other students?\",\n    \"Will I get updates when someone posts a new project?\",\n    \"Can I unfollow someone later?\",\n    \"How do I build my network?\",\n\n    # ≡ƒö╣ Real-time Chat\n    \"How do I join a public chat room?\",\n    \"What chat rooms are available?\",\n    \"Can I message someone privately?\",\n    \"Is chat available on mobile?\",\n\n    # ≡ƒö╣ Coding Leaderboards\n    \"What is the leaderboard for?\",\n    \"How is ranking calculated?\",\n    \"Does it track GitHub activity?\",\n    \"Can I connect my LeetCode account?\",\n    \"How often is the leaderboard updated?\",\n\n    # ≡ƒö╣ LinkedIn Integration\n    \"How do I link my LinkedIn account?\",\n    \"Will my LinkedIn posts show automatically?\",\n    \"Can I remove my LinkedIn integration?\",\n\n    # ≡ƒö╣ User Profiles\n    \"How do I update my profile?\",\n    \"What details can I add to my profile?\",\n    \"Can I link my GitHub and LeetCode profiles?\",\n    \"Can I add certifications and skills to my profile?\",\n    \"Who can view my profile?\",\n\n    # ≡ƒö╣ General / Other\n    \"What is this website about?\",\n    \"Who is this website for?\",\n    \"Is there a free plan?\",\n    \"How do I contact support?\",\n    \"I forgot my password, what do I do?\",\n    \"Website not loading, what should I do?\",\n    \"Site looks different on mobile, is that normal?\"\n]\n\ndocuments = [\n    # ≡ƒö╣ Project Showcase\n    \"Go to your profile and click ΓÇÿAdd ProjectΓÇÖ to upload project details.\",\n    \"Yes, you can attach images, videos, and documents to showcase your project better.\",\n    \"When adding a project, you can paste your GitHub or live demo link.\",\n    \"Your projects will appear on your profile and in the project showcase section.\",\n    \"Yes, other students can view and interact with your projects.\",\n\n    # ≡ƒö╣ Peer Networking\n    \"Click the ΓÇÿFollowΓÇÖ button on a studentΓÇÖs profile to follow them.\",\n    \"Yes, youΓÇÖll be notified when someone you follow uploads a new project or update.\",\n    \"Yes, you can unfollow anytime from their profile.\",\n    \"Engage with projects, follow peers, and join chats to build your network.\",\n\n    # ≡ƒö╣ Real-time Chat\n    \"Go to the chat section and select the room you want to join.\",\n    \"Common chat rooms include General, Projects, and Help.\",\n    \"Yes, you can send private one-on-one messages.\",\n    \"Yes, the chat feature is available on both desktop and mobile.\",\n\n    # ≡ƒö╣ Coding Leaderboards\n    \"The leaderboard shows top performers based on coding activity.\",\n    \"Ranking is calculated from GitHub commits and LeetCode problems solved.\",\n    \"Yes, your GitHub contributions are tracked.\",\n    \"Yes, you can connect your LeetCode account from your profile settings.\",\n    \"The leaderboard is updated daily to reflect your progress.\",\n\n    # ≡ƒö╣ LinkedIn Integration\n    \"You can link your LinkedIn account from your profile settings.\",\n    \"Yes, your latest LinkedIn posts will automatically appear on your feed.\",\n    \"Yes, you can remove LinkedIn integration anytime from settings.\",\n\n    # ≡ƒö╣ User Profiles\n    \"Go to your profile page and click ΓÇÿEditΓÇÖ to update your details.\",\n    \"You can add skills, certifications, projects, achievements, and links to external profiles.\",\n    \"Yes, you can link GitHub, LinkedIn, and LeetCode accounts from your profile.\",\n    \"Yes, certifications and skills can be added under the profile section.\",\n    \"Your profile is visible to other students and mentors on the platform.\",\n\n    # ≡ƒö╣ General / Other\n    \"This platform helps students showcase projects, connect with peers, and grow professionally.\",\n    \"It "},"backend/src/chatbot/requirements.txt":{"path":"backend/src/chatbot/requirements.txt","content":"flask\nsentence-transformers\nfaiss-cpu\nnumpy\npyspellchecker\nflask-cors\n\n"},"backend/src/constants.js":{"path":"backend/src/constants.js","content":"export const DB_NAME = \"InnovationHubCEC\";\n"},"backend/src/controllers/activity.controller.js":{"path":"backend/src/controllers/activity.controller.js","content":"import { asyncHandler } from \"../utils/asynchandler.js\";\nimport { ApiResponse } from \"../utils/apiresponsehandler.js\";\nimport  {ApiError} from '../utils/apierrorhandler.js';\nimport { GithubStats } from '../models/github.model.js';\nimport { LeetcodeStats } from '../models/leetcode.model.js';\nimport axios from 'axios';\n\n\nconst getGithubActivity = asyncHandler(async (req, res) => {\n  const { userId } = req.params;\n  \n  const githubStats = await GithubStats.findOne({ user: userId }).populate('user');\n  \n  if (!githubStats) {\n    throw new ApiError(404, 'GitHub stats not found for this user');\n  }\n  \n\n  const calendar = [];\n  \n\n  if (githubStats.submissionCalendar) {\n    try {\n\n      const calendarData = typeof githubStats.submissionCalendar === 'string' \n        ? JSON.parse(githubStats.submissionCalendar) \n        : githubStats.submissionCalendar;\n      \n      Object.entries(calendarData).forEach(([timestamp, count]) => {\n        const date = new Date(parseInt(timestamp) * 1000).toISOString().split('T')[0];\n        calendar.push({ date, count });\n      });\n    } catch (error) {\n      console.error('Error parsing GitHub submission calendar:', error);\n    }\n  }\n  \n  return res.status(200).json(\n    new ApiResponse(200, {\n      username: githubStats.username,\n      calendar,\n      languages: githubStats.languages || {},\n      topLanguage: githubStats.topLanguage || null,\n    }, 'GitHub activity data fetched successfully')\n  );\n});\n\n\nconst getLeetcodeActivity = asyncHandler(async (req, res) => {\n  const { userId } = req.params;\n  \n  const leetcodeStats = await LeetcodeStats.findOne({ user: userId }).populate('user');\n  \n  if (!leetcodeStats) {\n    throw new ApiError(404, 'LeetCode stats not found for this user');\n  }\n  \n  const calendar = [];\n  \n  if (leetcodeStats.submissionCalendar) {\n    try {\n      const calendarData = typeof leetcodeStats.submissionCalendar === 'string' \n        ? JSON.parse(leetcodeStats.submissionCalendar) \n        : leetcodeStats.submissionCalendar;\n      \n      Object.entries(calendarData).forEach(([timestamp, count]) => {\n        const date = new Date(parseInt(timestamp) * 1000).toISOString().split('T')[0];\n        calendar.push({ date, count });\n      });\n    } catch (error) {\n      console.error('Error parsing LeetCode submission calendar:', error);\n    }\n  }\n  \n  return res.status(200).json(\n    new ApiResponse(200, {\n      username: leetcodeStats.username,\n      calendar,\n      languages: leetcodeStats.languages || {},\n      topLanguage: leetcodeStats.topLanguage || null,\n    }, 'LeetCode activity data fetched successfully')\n  );\n});\n\nexport {\n  getGithubActivity,\n  getLeetcodeActivity\n};"},"backend/src/controllers/chat.controller.js":{"path":"backend/src/controllers/chat.controller.js","content":"import { asyncHandler } from \"../utils/asynchandler.js\";\nimport { ApiError } from \"../utils/apierrorhandler.js\";\nimport { ApiResponse } from \"../utils/apiresponsehandler.js\";\nimport { ChatRoom } from \"../models/chatroom.model.js\";\nimport { Message } from \"../models/message.model.js\";\nimport { uploadOnCloudinary } from \"../utils/cloudinary.js\";\nimport { presenceStore, getIO, emitToUser } from \"../socket.js\";\n\nexport const ensureDefaultRooms = async () => {\n  try {\n    const count = await ChatRoom.countDocuments({ isPrivate: false });\n    if (count === 0) {\n      await ChatRoom.insertMany([\n        { name: \"General\", isPrivate: false },\n        { name: \"Projects\", isPrivate: false },\n        { name: \"Random\", isPrivate: false },\n      ]);\n    }\n  } catch (e) {\n    throw new ApiError(500, \"Failed to ensure default rooms\", e.message);\n  }\n};\n\nexport const reactToMessage = asyncHandler(async (req, res) => {\n  try {\n    const { messageId } = req.params;\n    const { emoji } = req.body || {};\n    const userId = req.user._id.toString();\n    if (!messageId) throw new ApiError(400, \"messageId required\");\n    if (!emoji) throw new ApiError(400, \"emoji required\");\n\n    const msg = await Message.findById(messageId);\n    if (!msg) throw new ApiError(404, \"Message not found\");\n\n    if (!msg.reactions) msg.reactions = new Map();\n    const current = Array.isArray(msg.reactions.get(emoji)) ? msg.reactions.get(emoji) : [];\n    const exists = current.map(String).includes(userId);\n    const updated = exists ? current.filter((u) => String(u) !== userId) : [...current, userId];\n    msg.reactions.set(emoji, updated);\n    await msg.save();\n\n    const payload = { _id: msg._id.toString(), reactions: Object.fromEntries(msg.reactions) };\n\n    const io = getIO();\n    if (msg.roomId) {\n      io?.to(msg.roomId.toString()).emit(\"messageUpdated\", payload);\n    } else if (msg.receiverUser) {\n      emitToUser(String(msg.receiverUser), \"messageUpdated\", payload);\n      emitToUser(String(msg.sender), \"messageUpdated\", payload);\n    }\n\n    return res.status(200).json(new ApiResponse(200, payload, \"Reaction updated\"));\n  } catch (e) {\n    throw new ApiError(500, \"Failed to react to message\", e.message);\n  }\n});\n\nexport const pinMessage = asyncHandler(async (req, res) => {\n  try {\n    const { messageId } = req.params;\n    if (!messageId) throw new ApiError(400, \"messageId required\");\n    const msg = await Message.findById(messageId);\n    if (!msg) throw new ApiError(404, \"Message not found\");\n\n    let prevPinned = null;\n    if (msg.roomId) {\n      prevPinned = await Message.findOneAndUpdate({ roomId: msg.roomId, pinned: true, _id: { $ne: msg._id } }, { $set: { pinned: false } }, { new: true });\n    } else if (msg.receiverUser) {\n      const a = msg.sender;\n      const b = msg.receiverUser;\n      prevPinned = await Message.findOneAndUpdate({ pinned: true, $or: [ { sender: a, receiverUser: b }, { sender: b, receiverUser: a } ], _id: { $ne: msg._id } }, { $set: { pinned: false } }, { new: true });\n    }\n\n    if (!msg.pinned) {\n      msg.pinned = true;\n      await msg.save();\n    }\n\n    const io = getIO();\n    const updates = [];\n    updates.push({ _id: msg._id.toString(), pinned: true });\n    if (prevPinned) updates.push({ _id: prevPinned._id.toString(), pinned: false });\n\n    if (msg.roomId) {\n      updates.forEach((u) => io?.to(msg.roomId.toString()).emit(\"messageUpdated\", u));\n    } else if (msg.receiverUser) {\n      updates.forEach((u) => {\n        emitToUser(String(msg.receiverUser), \"messageUpdated\", u);\n        emitToUser(String(msg.sender), \"messageUpdated\", u);\n      });\n    }\n\n    return res.status(200).json(new ApiResponse(200, { updates }, \"Message pinned\"));\n  } catch (e) {\n    throw new ApiError(500, \"Failed to pin message\", e.message);\n  }\n});\n\nexport const unpinMessage = asyncHandler(async (req, res) => {\n  try {\n    const { messageId } = req.params;\n    if (!messageId) throw new ApiError(400, \"messageId required\");\n    const msg = await Message.findById(messageId);\n    if (!msg) throw new ApiError(404, \"Message not found\");\n\n    if (msg.pinned) {\n "},"backend/src/controllers/competition.controller.js":{"path":"backend/src/controllers/competition.controller.js","content":"import { Competition } from \"../models/competition.model.js\";\nimport { ApiResponse } from \"../utils/apiresponsehandler.js\";\nimport { ApiError } from \"../utils/apierrorhandler.js\";\nimport { uploadOnCloudinary } from \"../utils/cloudinary.js\";\n\nexport const createCompetition = async (req, res, next) => {\n  if (!req.user.isAdmin) {\n   return res\n   .status(403)\n   .json(new ApiResponse(403, null, \"Forbidden: Admins only\"))\n  \n  } else {\n    try {\n      const { title, description, startDate, endDate, link, teamsize, Prize, Tag, Reqirements, isTeamEvent } = req.body;\n\n      if (!title || !description || !startDate || !endDate || !link || !Tag || !Reqirements) {\n        return res\n          .status(400)\n          .json(\n            new ApiResponse(\n              400,\n              null,\n              \"All required fields must be provided\"\n            )\n          );\n      }\n\n      const coverimageLocalPath =\n        req.files && req.files.coverImage && req.files.coverImage[0]\n          ? req.files.coverImage[0].path\n          : null;\n      let coverimageUrl;\n      if (coverimageLocalPath) {\n        const coverImage = await uploadOnCloudinary(coverimageLocalPath);\n        coverimageUrl = coverImage?.secure_url;\n      }\n      const competition = new Competition({\n        title,\n        description,\n        startDate,\n        endDate,\n        link,\n        teamsize,\n        Prize,\n        Tag,\n        Reqirements,\n        isTeamEvent: isTeamEvent === 'true',\n        ...(coverimageUrl && { coverImage: coverimageUrl }),\n      });\n\n      await competition.save();\n      return res\n        .status(200)\n        .json(\n          new ApiResponse(200, competition, \"Competition created successfully\")\n        );\n    } catch (err) {\n      throw new ApiError(500, err.message, \"bhai err\");\n    }\n  }\n};\n\nexport const listCompetitions = async (req, res, next) => {\n  try {\n    const competitions = await Competition.find().sort({ createdAt: -1 });\n    return res\n      .status(200)\n      .json(\n        new ApiResponse(200, competitions, \"Competitions fetched successfully\")\n      );\n  } catch (e) {\n    throw new ApiError(500, e.message);\n  }\n};\nexport const applyToCompetition = async (req, res, next) => {\n  try {\n    const competitionId = req.params.id;\n    const userId = req.user._id;\n\n    const competition = await Competition.findById(competitionId);\n    if (!competition) {\n      return res\n        .status(404)\n        .json(new ApiResponse(404, null, \"Competition not found\"));\n    }\n\n    if (competition.aplliedBy.includes(userId)) {\n      return res\n        .status(400)\n        .json(\n          new ApiResponse(\n            400,\n            null,\n            \"You have already applied to this competition\"\n          )\n        );\n    }\n\n    competition.aplliedBy.push(userId);\n    competition.applicationCount += 1;\n    await competition.save();\n\n    return res\n      .status(200)\n      .json(\n        new ApiResponse(200, competition, \"Applied to competition successfully\")\n      );\n  } catch (err) {\n    throw new ApiError(500, err.message);\n  }\n};\n\nexport const getCompetitionDetails = async (req, res, next) => {\n  try {\n    const competitionId = req.params.id;\n    const competition = await Competition.findById(competitionId).populate(\n      \"aplliedBy\",\n      \"fullname email\"\n    );\n    if (!competition) {\n      return res\n        .status(404)\n        .json(new ApiResponse(404, null, \"Competition not found\"));\n    }\n    return res\n      .status(200)\n      .json(\n        new ApiResponse(\n          200,\n          competition,\n          \"Competition details fetched successfully\"\n        )\n      );\n  } catch (err) {\n    throw new ApiError(500, err.message);\n  }\n};\nexport const deleteCompetition = async (req, res, next) => {\n  if (!req.user.isAdmin) {\n    return res\n      .status(403)\n      .json(new ApiResponse(403, null, \"Forbidden: Admins only\"));\n  } else {\n    try {\n      const competitionId = req.params.id;\n      const competition = await Competition.findByIdAndDelete(competitionId);\n      if (!competition) {\n        return res\n          .status(404)\n   "},"backend/src/controllers/contest.controller.js":{"path":"backend/src/controllers/contest.controller.js","content":"import { ApiError } from \"../utils/apierrorhandler.js\";\nimport { ApiResponse } from \"../utils/apiresponsehandler.js\";\nimport { asyncHandler } from \"../utils/asynchandler.js\";\nimport { Contest } from \"../models/contest.model.js\";\nimport { Problem } from \"../models/problem.model.js\";\nimport { Submission } from \"../models/submission.model.js\";\nimport { runSingleTest } from \"../services/judge0.service.js\";\n\nfunction ensureWindow(contest) {\n  const now = new Date();\n  if (now < new Date(contest.startAt)) throw new ApiError(403, \"Contest has not started yet\");\n  if (now > new Date(contest.endAt)) throw new ApiError(403, \"Contest has ended\");\n}\n\nexport const createContest = asyncHandler(async (req, res) => {\n  try {\n  const { title, description, startAt, endAt, visibility = \"public\" } = req.body;\n  if (!title || !description || !startAt || !endAt) {\n    throw new ApiError(400, \"title, description, startAt, endAt are required\");\n  }\n  const contest = await Contest.create({\n    title,\n    description,\n    startAt: new Date(startAt),\n    endAt: new Date(endAt),\n    createdBy: req.user._id,\n    visibility\n  });\n  return res.status(201).json(new ApiResponse(201, contest, \"Contest created\"));\n}\n\ncatch (e) {\n  throw new ApiError(500, \"Internal Server Error\", e);\n}\n}\n);\n\n\nexport const listContests = asyncHandler(async (_req, res) => {\n  try {\n  const contests = await Contest.find({}).select(\"title description startAt endAt visibility\").sort({ startAt: -1 });\n  return res.status(200).json(new ApiResponse(200, contests));\n  }\n  catch (e) {\n    throw new ApiError(500, \"Internal Server Error\", e);\n  }\n});\n\nexport const getContest = asyncHandler(async (req, res) => {\n  try{\n  const { id } = req.params;\n  const contest = await Contest.findById(id).populate({ path: \"problems\", select: \"title allowedLangs timeLimit memoryLimit\" });\n  if (!contest) throw new ApiError(404, \"Contest not found\");\n  return res.status(200).json(new ApiResponse(200, contest));\n  }\n  catch (e) {\n    throw new ApiError(500, \"Internal Server Error\", e);\n  }\n});\n\nexport const addProblem = asyncHandler(async (req, res) => {\n  try{\n  const { contestId } = req.params;\n  const contest = await Contest.findById(contestId);\n  if (!contest) throw new ApiError(404, \"Contest not found\");\n  const {\n    title,\n    statement,\n    inputFormat,\n    outputFormat,\n    constraints,\n    samples = [],\n    testCases = [],\n    allowedLangs = [54, 63, 71, 62, 50],\n    timeLimit = 2.0,\n    memoryLimit = 128000\n  } = req.body;\n  if (!title || !statement) throw new ApiError(400, \"title and statement required\");\n  const problem = await Problem.create({\n    title,\n    statement,\n    inputFormat,\n    outputFormat,\n    constraints,\n    samples,\n    testCases,\n    allowedLangs,\n    timeLimit,\n    memoryLimit\n  });\n  contest.problems.push(problem._id);\n  await contest.save();\n  return res.status(201).json(new ApiResponse(201, problem, \"Problem added\"));\n}\ncatch (e) {\n  throw new ApiError(500, \"Internal Server Error\", e);\n}\n\n});\n\nexport const getProblem = asyncHandler(async (req, res) => {\n  try{\n  const { contestId, problemId } = req.params;\n  const contest = await Contest.findById(contestId);\n  if (!contest) throw new ApiError(404, \"Contest not found\");\n  if (!contest.problems.some((p) => String(p) === String(problemId))) {\n    throw new ApiError(404, \"Problem not part of this contest\");\n  }\n  const problem = await Problem.findById(problemId).select(\"title statement inputFormat outputFormat constraints samples allowedLangs timeLimit memoryLimit\");\n  if (!problem) throw new ApiError(404, \"Problem not found\");\n  return res.status(200).json(new ApiResponse(200, problem));\n}\ncatch(e){\n  throw new ApiError(500,\"Server Error\", e)\n}\n});\n\n// Execute a custom test run (no persistence)\nexport const runCustomTest = asyncHandler(async (req, res) => {\n  const { contestId, problemId } = req.params;\n  const { languageId, sourceCode, stdin = '', expectedOutput } = req.body || {};\n  if (!languageId || !sourceCode) throw new ApiError(400, \"languageId and sourceCode required\");\n\n  const contest = await Contest.findById("},"backend/src/controllers/github.controller.js":{"path":"backend/src/controllers/github.controller.js","content":"import cron from \"node-cron\";\nimport axios from \"axios\";\nimport { User } from \"../models/user.model.js\"; \nimport { GithubStats } from \"../models/github.model.js\";\nimport { ApiError } from \"../utils/apierrorhandler.js\";\n\nconst BATCH_SIZE = 100; \nconst fetchContributionData = async (username) => {\n  try {\n    const apiUrl = `https://github-contributions-api.jogruber.de/v4/${username}`;\n    const response = await axios.get(apiUrl);\n    if (response.data && response.data.contributions && response.data.total) {\n      return response.data;\n    }\n    return null;\n  } catch (error) {\n    console.error(`Failed to fetch data for ${username}:`, error.message);\n    return null;\n  }\n};\n\nconst fetchLanguagesData = async (username) => {\n  try {\n    const reposUrl = `https://api.github.com/users/${username}/repos?per_page=100`;\n    const reposResponse = await axios.get(reposUrl);\n    const repos = reposResponse.data;\n    \n    if (!Array.isArray(repos) || repos.length === 0) {\n      return { languages: {}, topLanguage: \"\" };\n    }\n    \n    const languageTotals = {};\n    \n    for (const repo of repos) {\n      if (repo.fork) continue; \n      \n      const languagesUrl = `https://api.github.com/repos/${username}/${repo.name}/languages`;\n      const languagesResponse = await axios.get(languagesUrl);\n      const repoLanguages = languagesResponse.data;\n      \n      for (const [language, bytes] of Object.entries(repoLanguages)) {\n        languageTotals[language] = (languageTotals[language] || 0) + bytes;\n      }\n      \n      await new Promise(resolve => setTimeout(resolve, 100));\n    }\n    \n    let topLanguage = \"\";\n    let maxBytes = 0;\n    \n    for (const [language, bytes] of Object.entries(languageTotals)) {\n      if (bytes > maxBytes) {\n        maxBytes = bytes;\n        topLanguage = language;\n      }\n    }\n    \n    return { languages: languageTotals, topLanguage };\n  } catch (error) {\n    console.error(`Failed to fetch languages for ${username}:`, error.message);\n    return { languages: {}, topLanguage: \"\" };\n  }\n};\n\nconst calculateStats = (data) => {\n    const today = new Date();\n    const toISO = (d) => d.toISOString().slice(0, 10);\n    const todayStr = toISO(today);\n  \n    const getMonthlyTotal = (year, month) =>\n      data.contributions\n        .filter((c) => {\n          const [cYear, cMonth] = c.date.split(\"-\").map(Number);\n          return cYear === year && cMonth === month;\n        })\n        .reduce((sum, c) => sum + c.count, 0);\n\n    return {\n        todayContributions: data.contributions.find((c) => c.date === todayStr)?.count || 0,\n        thisMonthContributions: getMonthlyTotal(today.getFullYear(), today.getMonth() + 1),\n        lastMonthContributions: getMonthlyTotal(new Date(new Date().setMonth(today.getMonth() - 1)).getFullYear(), new Date(new Date().setMonth(today.getMonth() - 1)).getMonth() + 1),\n        thisYearContributions: data.total[today.getFullYear()] || 0,\n        totalContributions: Object.values(data.total).reduce((sum, count) => sum + count, 0),\n    };\n};\nconst updateGithubStatsJob = async () => {\n\n  try {\n    const usersToUpdate = await User.find({ \n        github: { $exists: true, $ne: null } \n    }).sort({ 'githubStats.lastUpdated': 1 }).limit(BATCH_SIZE);\n\n    if (usersToUpdate.length === 0) {\n        console.log(\"No users to update.\");\n        return;\n    }\n\n    for (const user of usersToUpdate) {\n      const githubUrl = user.github ;\n      if (!githubUrl) continue;\n      \n      const username = githubUrl.split(\"/\").pop();\n      if (!username) continue;\n\n      const rawData = await fetchContributionData(username);\n      if (!rawData) continue;\n\n      const stats = calculateStats(rawData);\n      \n      const { languages, topLanguage } = await fetchLanguagesData(username);\n      \n      await GithubStats.findOneAndUpdate(\n        { user: user._id },\n        {\n          $set: {\n            username,\n            ...stats,\n            languages,\n            topLanguage,\n            lastUpdated: new Date(),\n          },\n        },\n        { upsert: true, new: true }\n      );\n      \n      await new Promise(resolve ="},"backend/src/controllers/githubleaderboard.controller.js":{"path":"backend/src/controllers/githubleaderboard.controller.js","content":"import { asyncHandler } from \"../utils/asynchandler.js\";\nimport { ApiResponse } from \"../utils/apiresponsehandler.js\";\nimport { GithubStats } from \"../models/github.model.js\";\nimport { ApiError } from \"../utils/apierrorhandler.js\";\n\nconst getGithubLeaderboard = asyncHandler(async (req, res) => {\n  const page = parseInt(req.query.page) || 1;\n  const limit = parseInt(req.query.limit) || 25;\n  const skip = (page - 1) * limit;\n\n  const sortBy = req.query.sortBy || \"totalContributions\";\n  const validSortFields = [\n    \"totalContributions\",\n    \"thisYearContributions\",\n    \"thisMonthContributions\",\n    \"lastMonthContributions\",\n    \"todayContributions\",\n  ];\n\n  if (!validSortFields.includes(sortBy)) {\n    throw new ApiError(400, \"Invalid sort field.\");\n  }\n\n  const leaderboard = await GithubStats.find({})\n    .sort({ [sortBy]: -1 })\n    .skip(skip)\n    .limit(limit)\n    .populate(\"user\", \"fullname avatar\")\n    .select(\"-_id -__v\");\n\n  const totalRecords = await GithubStats.countDocuments();\n\n  if (!leaderboard) {\n    throw new ApiError(404, \"Leaderboard data not available.\");\n  }\n\n  return res.status(200).json(\n    new ApiResponse(\n      200,\n      {\n        leaderboard,\n        currentPage: page,\n        totalPages: Math.ceil(totalRecords / limit),\n        totalUsers: totalRecords,\n      },\n      \"Leaderboard fetched successfully from the database\"\n    )\n  );\n});\nexport { getGithubLeaderboard };\n"},"backend/src/controllers/leetcodeleaderboard.controller.js":{"path":"backend/src/controllers/leetcodeleaderboard.controller.js","content":"import { asyncHandler } from \"../utils/asynchandler.js\";\nimport { ApiResponse } from \"../utils/apiresponsehandler.js\";\nimport { LeetcodeStats } from \"../models/leetcode.model.js\";\nimport { User } from \"../models/user.model.js\";\nimport axios from \"axios\";\nimport { ApiError } from \"../utils/apierrorhandler.js\";\n\nfunction extractLeetcodeUsername(urlOrUsername) {\n  if (!urlOrUsername) return '';\n  const match = urlOrUsername.match(/leetcode\\.com\\/u\\/([^/]+)/i);\n  if (match) return match[1];\n  return urlOrUsername.split(\"/\").pop();\n}\n\nconst fetchLeetcodeLanguageData = async (username) => {\n  try {\n    const url = 'https://leetcode.com/graphql';\n    \n    const query = {\n      query: `\n        query userProfile($username: String!) {\n          matchedUser(username: $username) {\n            submitStats {\n              acSubmissionNum {\n                difficulty\n                count\n              }\n            }\n            languageProblemCount {\n              languageName\n              problemsSolved\n            }\n          }\n        }\n      `,\n      variables: { username }\n    };\n    \n    const response = await axios.post(url, query, {\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    });\n    \n    if (response.data && response.data.data && response.data.data.matchedUser) {\n      const languageData = response.data.data.matchedUser.languageProblemCount || [];\n      \n      const languages = {};\n      let topLanguage = \"\";\n      let maxSolved = 0;\n      \n      languageData.forEach(item => {\n        languages[item.languageName] = item.problemsSolved;\n        \n        if (item.problemsSolved > maxSolved) {\n          maxSolved = item.problemsSolved;\n          topLanguage = item.languageName;\n        }\n      });\n      \n      return { languages, topLanguage };\n    }\n    \n    return { languages: {}, topLanguage: \"\" };\n  } catch (error) {\n    console.error(`Failed to fetch language data for ${username}:`, error.message);\n    return { languages: {}, topLanguage: \"\" };\n  }\n};\n\nconst fetchLeetcodeStatsForUser = async (user) => {\n  const username = extractLeetcodeUsername(user.leetcode);\n  if (!username) return null;\n  const url = `https://leetcode-stats-api.herokuapp.com/${username}`;\n  try {\n    const response = await axios.get(url);\n    if (response.data && response.data.status === \"success\") {\n      const data = response.data;\n      \n      const { languages, topLanguage } = await fetchLeetcodeLanguageData(username);\n      \n      const stats = {\n        user: user._id,\n        username: username,\n        ranking: data.ranking || Number.MAX_SAFE_INTEGER,\n        totalSolved: data.totalSolved,\n        easySolved: data.easySolved,\n        mediumSolved: data.mediumSolved,\n        hardSolved: data.hardSolved,\n        acceptanceRate: data.acceptanceRate,\n        contributionPoints: data.contributionPoints,\n        reputation: data.reputation,\n        submissionCalendar: data.submissionCalendar,\n        languages,\n        topLanguage,\n        lastUpdated: new Date()\n      };\n      await LeetcodeStats.findOneAndUpdate(\n        { user: user._id },\n        stats,\n        { upsert: true, new: true }\n      );\n      return stats;\n    }\n    return console.error(`Failed to fetch stats for ${username}:`, response.data.message);\n  } catch (err) {\n   return new ApiError(500, \"Failed to fetch LeetCode stats\");\n  }\n};\n\nconst refreshAllLeetcodeStats = async () => {\n  try{\n  const users = await User.find({ leetcode: { $exists: true, $ne: null, $ne: \"\" } });\n  if (users.length === 0) {\n    console.log(\"No users with LeetCode profiles found.\");\n    return;\n  }\n  await Promise.all(users.map(fetchLeetcodeStatsForUser));\n   \n  }\n  catch (error) {\n    throw new ApiError(500, \"Failed to refresh LeetCode stats for all users\");\n  }\n  \n};\n\n\n\nconst getLeetcodeLeaderboard = asyncHandler(async (req, res) => {\n    try {\n  const leaderboard = await LeetcodeStats.find({})\n    .sort({ ranking: 1 })\n    .populate(\"user\", \"fullname avatar leetcode\")\n    .select(\"-__v -submissionCalendar \");\n  return res.status(200).json(new ApiResponse(200, { leaderboard },"},"backend/src/controllers/linkedinpost.controller.js":{"path":"backend/src/controllers/linkedinpost.controller.js","content":"import { LinkedinPost } from \"../models/linkedinpost.model.js\";\nimport { asyncHandler } from \"../utils/asynchandler.js\";\nimport { ApiError } from \"../utils/apierrorhandler.js\";\nimport axios from \"axios\";\nimport { ApiResponse } from \"../utils/apiresponsehandler.js\";\nconst APIFY_TOKEN = process.env.APIFY_TOKEN;\nconst APIFY_RUN_URL = `https://api.apify.com/v2/acts/${process.env.APIFY_ACTOR_ID}/runs?token=${APIFY_TOKEN}`;\nconst APIFY_DATASET_URL = `https://api.apify.com/v2/datasets/${process.env.APIFY_DATASET_ID}/items?token=${APIFY_TOKEN}`;\n\nconst linkpostUpload = asyncHandler(async (req, res) => {\n  try {\n    const  username = req.user.linkedin;\n    const userId = req.user._id;\n\n    const actorInput = {\n      deepScrape: false,\n      limitPerSource: 10,\n      rawData: false,\n      urls: [username],\n    };\n\n    const runResponse = await axios.post(APIFY_RUN_URL, actorInput, {\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n    });\n\n    const runId = runResponse.data.data.id;\n\n    let isFinished = false;\n    let datasetId = null;\n    for (let i = 0; i < 10 && !isFinished; i++) {\n      const statusRes = await axios.get(\n        `https://api.apify.com/v2/actor-runs/${runId}`,\n        {\n          headers: { Authorization: `Bearer ${APIFY_TOKEN}` },\n        }\n      );\n\n      if (statusRes.data.data.status === \"SUCCEEDED\") {\n        isFinished = true;\n        datasetId = statusRes.data.data.defaultDatasetId;\n      } else {\n        await new Promise((r) => setTimeout(r, 5000));\n      }\n    }\n\n    if (!isFinished || !datasetId) {\n      return res\n        .status(500)\n        .json({ message: \"Apify scraping timeout or failed.\" });\n    }\n\n    const dataResponse = await axios.get(\n      `https://api.apify.com/v2/datasets/${datasetId}/items`,\n      {\n        params: { clean: true },\n        headers: { Authorization: `Bearer ${APIFY_TOKEN}` },\n      }\n    );\n\n    const scrapedData = dataResponse.data;\n\n    const postsToSave = scrapedData.map((post) => ({\n      owner: userId,\n      url: post.url,\n      text: post.text || \"\",\n      images: Array.isArray(post.images)\n        ? post.images.map((img) => ({ value: img }))\n        : [],\n      createdAt: post.date ? new Date(post.date) : new Date(),\n    }));\n\n    try {\n      await LinkedinPost.insertMany(postsToSave, { ordered: false });\n    } catch (err) {\n      if (!(err.name === \"BulkWriteError\" && err.code === 11000)) {\n        throw err;\n      }\n      console.warn(\"Some duplicates were skipped.\");\n    }\n    res.status(200).json({ message: \"Posts saved\", count: postsToSave.length });\n  } catch (err) {\n    //console.error(\"Error in /linkedinpost:\", err);\n    res.status(500, err.me).json({ err: \"Server error\" });\n  }\n});\nconst getlinkedinPosts = asyncHandler(async (req, res) => {\n  try {\n    let { page = 1, limit = 10 } = req.query;\n    page = parseInt(page);\n    limit = parseInt(limit);\n    const total = await LinkedinPost.countDocuments();\n    const pipeline = [\n      { $sample: { size: limit } },\n      {\n        $lookup: {\n          from: \"users\",\n          localField: \"owner\",\n          foreignField: \"_id\",\n          as: \"owner\"\n        }\n      },\n      { $unwind: { path: \"$owner\", preserveNullAndEmptyArrays: true } }\n    ];\n    const linkedinPosts = await LinkedinPost.aggregate(pipeline);\n    return res.status(200).json(\n      new ApiResponse(200, {\n        linkedinPosts,\n        currentPage: page,\n        totalPages: Math.ceil(total / limit),\n        totalPosts: total,\n      }, \"posts fetched successfully\")\n    );\n  } catch (e) {\n    throw new ApiError(500, e.message);\n  }\n});\n\n\nconst getlinkedinPostsByUser = asyncHandler(async (req, res) => {\n  try {\n    const { userId } = req.params;\n    let { page = 1, limit = 10 } = req.query;\n    page = parseInt(page);\n    limit = parseInt(limit);\n    const skip = (page - 1) * limit;\n\n    const total = await LinkedinPost.countDocuments({ owner: userId });\n    \n    const linkedinPosts = await LinkedinPost.find({ owner: userId })\n      .sort({ createdAt: -1 })\n      .skip(skip)\n      .limit(limit)\n      .populate(\"owner\", \"full"},"backend/src/controllers/mentor.controller.js":{"path":"backend/src/controllers/mentor.controller.js","content":"import { Mentor } from '../models/mentor.model.js';\nimport { User } from '../models/user.model.js';\nimport { MentorApplication } from '../models/mentorApplication.model.js';\nimport { ApiError } from '../utils/apierrorhandler.js';\nimport { ApiResponse } from '../utils/apiresponsehandler.js';\nimport { asyncHandler } from '../utils/asynchandler.js';\n\nconst getMentors = asyncHandler(async (req, res) => {\n  const { specialization, availability, q } = req.query;\n  const match = {};\n  if (specialization && specialization !== 'all') {\n    match.specialization = { $regex: specialization, $options: 'i' };\n  }\n  if (availability === 'available') match.available = true;\n  if (availability === 'unavailable') match.available = false;\n  if (q) {\n    match.$or = [\n      { name: { $regex: q, $options: 'i' } },\n      { specialization: { $regex: q, $options: 'i' } },\n      { skills: { $in: [new RegExp(q, 'i')] } }\n    ];\n  }\n  const mentors = await Mentor.find(match).sort({ rating: -1, sessionsCompleted: -1 }).limit(100);\n  const names = mentors.map(m => m.name).filter(Boolean);\n  const users = await User.find({ fullname: { $in: names } }, 'fullname avatar skills _id bio');\n  const userMap = new Map(users.map(u => [u.fullname, u]));\n\n  const enriched = mentors.map((m) => {\n    const obj = m.toObject();\n    const u = userMap.get(m.name);\n    if (u) {\n      obj.avatar = obj.avatar || u.avatar;\n      if ((!obj.skills || obj.skills.length === 0) && Array.isArray(u.skills)) {\n        obj.skills = u.skills;\n      }\n      if (!obj.bio && u.bio) obj.bio = u.bio;\n      obj.userId = u._id;\n    }\n    return obj;\n  });\n\n  return res.status(200).json(new ApiResponse(200, enriched, 'Mentors fetched'));\n});\n\nconst applyForMentor = asyncHandler(async (req, res) => {\n  const {\n    fullName,\n    email,\n    phone,\n    linkedin,\n    github,\n    portfolio,\n    specialization,\n    expertise,\n    experienceYears,\n    availability,\n    whySuitable,\n    page,\n    sent_at\n  } = req.body || {};\n\n  if (!fullName || !email || !specialization || !whySuitable) {\n    throw new ApiError(400, 'fullName, email, specialization and whySuitable are required');\n  }\n\n  const expertiseArray = Array.isArray(expertise)\n    ? expertise\n    : (typeof expertise === 'string' ? expertise.split(',').map(s => s.trim()).filter(Boolean) : []);\n\n  const doc = await MentorApplication.create({\n    fullName,\n    email,\n    phone,\n    linkedin,\n    github,\n    portfolio,\n    specialization,\n    expertise: expertiseArray,\n    experienceYears,\n    availability,\n    whySuitable,\n    page,\n    sent_at: sent_at ? new Date(sent_at) : new Date()\n  });\n\n  return res.status(201).json(new ApiResponse(201, { id: doc._id }, 'Application received'));\n});\nconst listMentorApplications = asyncHandler(async (req, res) => {\n  const { status = 'pending' } = req.query;\n  const match = {};\n  if (status && status !== 'all') match.status = status;\n  const apps = await MentorApplication.find(match).sort({ createdAt: -1 }).limit(200);\n  return res.status(200).json(new ApiResponse(200, apps, 'Applications fetched'));\n});\n\n\nconst approveMentorApplication = asyncHandler(async (req, res) => {\n  const { id } = req.params;\n  const appDoc = await MentorApplication.findById(id);\n  if (!appDoc) {\n    throw new ApiError(404, 'Application not found');\n  }\n  if (appDoc.status === 'approved') {\n    return res.status(200).json(new ApiResponse(200, { id: appDoc._id }, 'Already approved'));\n  }\n  appDoc.status = 'approved';\n  await appDoc.save();\n\n  const exists = await Mentor.findOne({ name: appDoc.fullName, specialization: appDoc.specialization });\n  if (!exists) {\n    await Mentor.create({\n      name: appDoc.fullName,\n      specialization: appDoc.specialization,\n      expertise: appDoc.expertise || [],\n      available: true,\n      bio: appDoc.whySuitable,\n    });\n  }\n\n  return res.status(200).json(new ApiResponse(200, { id: appDoc._id }, 'Application approved'));\n});\nconst rejectMentorApplication = asyncHandler(async (req, res) => {\n  const { id } = req.params;\n  const appDoc = await MentorApplication.findById(id);\n  if (!appDoc) {\n"},"backend/src/controllers/opportunity.controller.js":{"path":"backend/src/controllers/opportunity.controller.js","content":"import { Opportunity } from \"../models/opportunity.model.js\";\nimport { ApiResponse } from \"../utils/apiresponsehandler.js\";\nimport { ApiError } from \"../utils/apierrorhandler.js\";\n\nexport const bulkUpsertOpportunities = async (req, res, next) => {\n  try {\n    const items = Array.isArray(req.body?.items) ? req.body.items : [];\n    if (!items.length) {\n      return res\n        .status(400)\n        .json(new ApiResponse(400, null, \"items array is required\"));\n    }\n\n    const ops = items.map((it) => {\n      const type = (it.employment_type || \"\").toLowerCase() === \"internship\" ? \"internship\" : \"job\";\n      const doc = {\n        job_id: it.job_id,\n        title: it.title,\n        company: it.company,\n        location: it.location,\n        employment_type: it.employment_type,\n        remote: it.remote,\n        salary: it.salary,\n        posted_on: it.posted_on,\n        skills: it.skills || [],\n        good_to_have: it.good_to_have || [],\n        topics: it.topics || [],\n        buzzwords: it.buzzwords || [],\n        rounds: it.rounds,\n        cutoff: it.cutoff,\n        apply_link: it.apply_link,\n        description: it.description,\n        type,\n      };\n      return {\n        updateOne: {\n          filter: { job_id: it.job_id },\n          update: { $set: doc },\n          upsert: true,\n        },\n      };\n    });\n\n    const result = await Opportunity.bulkWrite(ops, { ordered: false });\n    const upserts = result.upsertedCount || 0;\n    const modified = result.modifiedCount || 0;\n\n    return res\n      .status(200)\n      .json(new ApiResponse(200, { upserts, modified }, \"opportunities upserted\"));\n  } catch (err) {\n    return next(new ApiError(500, err.message));\n  }\n};\n\nexport const listOpportunities = async (req, res, next) => {\n  try {\n    const { type = \"all\", q = \"\", page = 1, limit = 20 } = req.query;\n    const filter = {};\n    if (type !== \"all\") {\n      filter.type = type;\n    }\n    if (q) {\n      filter.$or = [\n        { title: { $regex: q, $options: \"i\" } },\n        { company: { $regex: q, $options: \"i\" } },\n      ];\n    }\n\n    const pageNum = Math.max(parseInt(page, 10) || 1, 1);\n    const limitNum = Math.min(Math.max(parseInt(limit, 10) || 20, 1), 100);\n\n    const [items, total] = await Promise.all([\n      Opportunity.find(filter)\n        .sort({ createdAt: -1 })\n        .skip((pageNum - 1) * limitNum)\n        .limit(limitNum),\n      Opportunity.countDocuments(filter),\n    ]);\n\n    return res\n      .status(200)\n      .json(new ApiResponse(200, { items, total, page: pageNum, limit: limitNum }));\n  } catch (err) {\n    return next(new ApiError(500, err.message));\n  }\n};\nexport const listInternship = async (req, res, next) => {\n  try {\n    const { type = \"intern\", q = \"\", page = 1, limit = 20 } = req.query;\n    const filter = {};\n    if (type !== \"all\") {\n      filter.type = type;\n    }\n    if (q) {\n      filter.$or = [\n        { title: { $regex: q, $options: \"i\" } },\n        { company: { $regex: q, $options: \"i\" } },\n      ];\n    }\n\n    const pageNum = Math.max(parseInt(page, 10) || 1, 1);\n    const limitNum = Math.min(Math.max(parseInt(limit, 10) || 20, 1), 100);\n\n    const [items, total] = await Promise.all([\n      Opportunity.find(filter)\n        .sort({ createdAt: -1 })\n        .skip((pageNum - 1) * limitNum)\n        .limit(limitNum),\n      Opportunity.countDocuments(filter),\n    ]);\n\n    return res\n      .status(200)\n      .json(new ApiResponse(200, { items, total, page: pageNum, limit: limitNum }));\n  } catch (err) {\n    return next(new ApiError(500, err.message));\n  }\n};"},"backend/src/controllers/post.controller.js":{"path":"backend/src/controllers/post.controller.js","content":"import { Post} from \"../models/post.model.js\";\nimport { ApiError } from \"../utils/apierrorhandler.js\";\nimport { ApiResponse } from \"../utils/apiresponsehandler.js\";\nimport { deleteFile, uploadOnCloudinary } from \"../utils/cloudinary.js\";\nimport { asyncHandler } from \"../utils/asynchandler.js\";\nimport { User } from \"../models/user.model.js\";\nimport mongoose from \"mongoose\";\n\nconst postUpload = asyncHandler(async (req, res) => {\n  try {\n    const { description, liveLink, githubLink } = req.body;\n    const userid = req.user._id;\n    const files = req.files?.postFile;\n    if (!files || files.length === 0) throw new ApiError(400, \"Post file(s) required\");\n    \n    const uploadedUrls = [];\n    for (const file of files) {\n      const uploadResult = await uploadOnCloudinary(file.path);\n      if (!uploadResult) throw new ApiError(400, \"Upload error\");\n      uploadedUrls.push(uploadResult.url);\n    }\n    const postPublish = await Post.create({\n      postFile: uploadedUrls,\n      description,\n      liveLink: liveLink || undefined,\n      githubLink: githubLink || undefined,\n      owner: userid,\n    });\n    if (!postPublish)\n      throw ApiError(500, \"Something went wrong while uploading\");\n    return res\n      .status(200)\n      .json(new ApiResponse(200, { postPublish }, \"Success\"));\n  } catch (e) {\n    throw new ApiError(400, e.message);\n  }\n});\n\nconst getAllPost = asyncHandler(async (req, res) => {\n  const { page = 1, limit = 10, query, userId } = req.query;\n  try {\n    const match = {};\n    if (query) {\n      match.description = { $regex: query, $options: \"i\" };\n    }\n    if (userId) {\n      match.owner = new mongoose.Types.ObjectId(userId);\n    }\n    const pipeline = [];\n    if (Object.keys(match).length) {\n      pipeline.push({ $match: match });\n    }\n    pipeline.push({ $sample: { size: parseInt(limit) } });\n    pipeline.push(\n      {\n        $lookup: {\n          from: \"users\",\n          localField: \"owner\",\n          foreignField: \"_id\",\n          as: \"owner\"\n        }\n      },\n      { $unwind: { path: \"$owner\", preserveNullAndEmptyArrays: true } },\n      {\n        $addFields: {\n          likesCount: { $size: { $ifNull: [\"$likes\", []] } },\n          commentsCount: { $size: { $ifNull: [\"$comments\", []] } }\n        }\n      }\n    );\n\n    if (req.user?._id) {\n      pipeline.push({\n        $addFields: {\n          isLiked: { $in: [ req.user._id, { $ifNull: [\"$likes\", []] } ] }\n        }\n      });\n    } else {\n      pipeline.push({ $addFields: { isLiked: false } });\n    }\n\n    pipeline.push({\n      $project: {\n        description: 1,\n        postFile: 1,\n        liveLink: 1,\n        githubLink: 1,\n        tags: 1,\n        views: 1,\n        createdAt: 1,\n        ispublished: 1,\n        likesCount: 1,\n        commentsCount: 1,\n        isLiked: 1,\n        owner: {\n          _id: \"$owner._id\",\n          fullname: \"$owner.fullname\",\n          avatar: \"$owner.avatar\"\n        }\n      }\n    });\n\n    const result = await Post.aggregate(pipeline);\n    const total = await Post.countDocuments(match);\n    return res.status(200).json(new ApiResponse(200, { result, total }, \"Success\"));\n  } catch (e) {\n    throw new ApiError(500, e.message);\n  }\n});\nconst getPostById = asyncHandler(async (req, res) => {\n  try {\n    const { postId } = req.params;\n    const postUrl = await Post.findById(postId);\n    if (!postUrl) throw new ApiError(404, \"post not found\");\n\n    return res\n      .status(200)\n      .json(new ApiResponse(200, { postUrl }, \"Success file \"));\n  } catch (e) {\n    throw new ApiError(404, e.message);\n  }\n});\nconst updatePost = asyncHandler(async (req, res) => {\n  try {\n    const { postId } = req.params;\n    const localFilePathofPost = req.file.path;\n\n    if (!localFilePathofPost) {\n      throw new ApiError(404, \"File not found\");\n    }\n\n    const uploadCloud = await uploadOnCloudnary(localFilePathofPost);\n\n    if (!uploadCloud.url) {\n      throw new ApiError(500, \"Unable to upload to cloud\");\n    }\n    const public_id_post = await Post.findById(postId);\n    const deleteFileServer = await deleteFile(\n      public_id_post.cloudinaryPostID\n   "},"backend/src/controllers/stats.controller.js":{"path":"backend/src/controllers/stats.controller.js","content":"import { asyncHandler } from \"../utils/asynchandler.js\";\nimport { ApiResponse } from \"../utils/apiresponsehandler.js\";\nimport { Post } from \"../models/post.model.js\";\nimport { Mentor } from \"../models/mentor.model.js\";\nimport { User } from \"../models/user.model.js\";\n\nexport const getLandingStats = asyncHandler(async (req, res) => {\n  const [publishedProjects, mentors, activeStudents] = await Promise.all([\n    Post.countDocuments({ ispublished: true }),\n    Mentor.countDocuments({}),\n    User.countDocuments({}),\n  ]);\n\n  const competitions = 0;\n\n  return res\n    .status(200)\n    .json(\n      new ApiResponse(200, {\n        publishedProjects,\n        mentors,\n        competitions,\n        activeStudents,\n      })\n    );\n});\n"},"backend/src/controllers/team.controller.js":{"path":"backend/src/controllers/team.controller.js","content":"import { Team } from \"../models/team.model.js\";\nimport { Competition } from \"../models/competition.model.js\";\nimport { ApiResponse } from \"../utils/apiresponsehandler.js\";\nimport { ApiError } from \"../utils/apierrorhandler.js\";\nimport crypto from \"crypto\";\n\nexport const createTeam = async (req, res, next) => {\n  try {\n    const { teamName, maxMembers } = req.body;\n    const competitionId = req.params.competitionId;\n    const userId = req.user._id;  \n\n    if (!competitionId || !teamName) {\n      return res\n        .status(400)\n        .json(new ApiResponse(400, null, \"Competition ID and team name are required\"));\n    }\n\n    const competition = await Competition.findById(competitionId);\n    if (!competition) {\n      return res\n        .status(404)\n        .json(new ApiResponse(404, null, \"Competition not found\"));\n    }\n\n    if (!competition.isTeamEvent) {\n      return res\n        .status(400)\n        .json(new ApiResponse(400, null, \"This competition is not a team event\"));\n    }\n\n    const existingTeam = await Team.findOne({\n      competition: competitionId,\n      $or: [{ leader: userId }, { members: userId }]\n    });\n\n    if (existingTeam) {\n      return res\n        .status(400)\n        .json(new ApiResponse(400, null, \"You are already part of a team for this competition\"));\n    }\n\n    const teamNameExists = await Team.findOne({\n      competition: competitionId,\n      name: teamName\n    });\n\n    if (teamNameExists) {\n      return res\n        .status(400)\n        .json(new ApiResponse(400, null, \"Team name already exists for this competition\"));\n    }\n\n    const invitationCode = crypto.randomBytes(8).toString('hex');\n    const expiryDate = new Date();\n    expiryDate.setDate(expiryDate.getDate() + 7); \n\n    const team = new Team({\n      name: teamName,\n      competition: competitionId,\n      leader: userId,\n      members: [userId], \n      invitationLinks: [{\n        code: invitationCode,\n        expiresAt: expiryDate,\n        isActive: true\n      }],\n      maxMembers: maxMembers || 4 \n    });\n    if(!team){\n      throw new ApiError(400,\"fuck off\",e.message)\n    }\n\n    await team.save();\n\n   \n    if (!competition.aplliedBy.includes(userId)) {\n      competition.aplliedBy.push(userId);\n      competition.applicationCount += 1;\n      await competition.save();\n    }\n\n    return res\n      .status(201)\n      .json(new ApiResponse(201, team, \"Team created successfully\"));\n  } catch (err) {\n    next(new ApiError(500, err.message));\n  }\n};\nexport const getTeamDetails = async (req, res, next) => {\n  try {\n    const { teamId } = req.params;\n    \n    const team = await Team.findById(teamId)\n      .populate('leader', 'fullname email')\n      .populate('members', 'fullname email')\n      .populate('competition', 'title description');\n    \n    if (!team) {\n      return res\n        .status(404)\n        .json(new ApiResponse(404, null, \"Team not found\"));\n    }\n    \n    return res\n      .status(200)\n      .json(new ApiResponse(200, team, \"Team details fetched successfully\"));\n  } catch (err) {\n    next(new ApiError(500, err.message));\n  }\n};\n\nexport const generateInvitationLink = async (req, res, next) => {\n  try {\n    const { teamId } = req.params;\n    const userId = req.user._id;\n    \n    const team = await Team.findById(teamId);\n    if (!team) {\n      return res\n        .status(404)\n        .json(new ApiResponse(404, null, \"Team not found\"));\n    }\n    \n    if (team.leader.toString() !== userId.toString()) {\n      return res\n        .status(403)\n        .json(new ApiResponse(403, null, \"Only team leader can generate invitation links\"));\n    }\n    \n    const invitationCode = crypto.randomBytes(8).toString('hex');\n    const expiryDate = new Date();\n    expiryDate.setDate(expiryDate.getDate() + 7); \n    \n    team.invitationLinks.push({\n      code: invitationCode,\n      expiresAt: expiryDate,\n      isActive: true\n    });\n    \n    await team.save();\n    \n    return res\n      .status(200)\n      .json(new ApiResponse(200, { invitationCode }, \"Invitation link generated successfully\"));\n  } catch (err) {\n    next(new ApiError(500, err.message));\n  "},"backend/src/controllers/user.controller.js":{"path":"backend/src/controllers/user.controller.js","content":"import { asyncHandler } from \"../utils/asynchandler.js\";\nimport { ApiError } from \"../utils/apierrorhandler.js\";\nimport { User } from \"../models/user.model.js\";\nimport { uploadOnCloudinary } from \"../utils/cloudinary.js\";\nimport { ApiResponse } from \"../utils/apiresponsehandler.js\";\nimport jwt from \"jsonwebtoken\";\nimport { OAuth2Client } from \"google-auth-library\";\nimport { emitToUser } from \"../socket.js\";\n\nconst generateAccessAndRefreshToken = async (userId) => {\n  try {\n    const user = await User.findById(userId);\n    const accessToken = user.generateAccessToken();\n    const refreshToken = user.generateRefreshToken();\n    user.refreshToken = refreshToken;\n    if (!user.branch) {\n      user.branch = 'CSE';\n    }\n    await user.save({ validateBeforeSave: false });\n    return { accessToken, refreshToken, newRefreshToken: refreshToken };\n  } catch (error) {\n    throw new ApiError(500, \"Error generating tokens\");\n  }\n};\n\nconst googleAuth = asyncHandler(async (req, res) => {\n  try {\n    const { idToken } = req.body || {};\n    if (!idToken) {\n      throw new ApiError(400, \"Missing Google ID token\");\n    }\n\n    const allowedAudiences = (process.env.GOOGLE_CLIENT_IDS || process.env.GOOGLE_CLIENT_ID || \"\")\n      .split(\",\")\n      .map(s => s.trim())\n      .filter(Boolean);\n    if (!allowedAudiences.length) {\n      throw new ApiError(500, \"Server misconfigured: GOOGLE_CLIENT_ID(S) missing\");\n    }\n    const client = new OAuth2Client();\n    let payload;\n    let lastError;\n    for (const aud of allowedAudiences) {\n      try {\n        const ticket = await client.verifyIdToken({ idToken, audience: aud });\n        payload = ticket.getPayload();\n        if (payload) break;\n      } catch (err) {\n        lastError = err;\n      }\n    }\n    if (!payload) {\n      throw new ApiError(400, lastError?.message || \"Invalid Google ID token\");\n    }\n\n    const googleId = payload.sub;\n    const email = payload.email;\n    const emailVerified = payload.email_verified;\n    const name = payload.name || payload.given_name || email?.split(\"@\")[0];\n\n    if (!email) {\n      throw new ApiError(400, \"Google account missing email\");\n    }\n\n    if (emailVerified === false) {\n      throw new ApiError(400, \"Google email not verified\");\n    }\n\n    let user = await User.findOne({ $or: [{ googleId }, { email }] });\n\n    if (!user) {\n      let fullname = (name || email.split(\"@\")[0]).trim();\n      if (!fullname) fullname = email.split(\"@\")[0];\n      let suffix = 0;\n      while (true) {\n        const exists = await User.findOne({ fullname });\n        if (!exists) break;\n        suffix += 1;\n        fullname = `${name}-${suffix}`;\n      }\n\n      user = await User.create({\n        fullname,\n        email,\n        provider: 'google',\n        googleId,\n        isVerified: true,\n        onboardingCompleted: false\n      });\n    } else {\n      if (!user.googleId) user.googleId = googleId;\n      user.provider = 'google';\n      user.isVerified = true;\n  \n      await user.save({ validateBeforeSave: false });\n    }\n\n    const { accessToken, refreshToken } = await generateAccessAndRefreshToken(user._id);\n    const safeUser = await User.findById(user._id).select(\"-password -refreshToken\");\n\n    const cookieOptions = {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      sameSite: process.env.NODE_ENV === 'production' ? 'None' : 'Lax',\n      path: '/',\n      maxAge: 24 * 60 * 60 * 1000\n    };\n\n    return res\n      .status(200)\n      .cookie(\"accessToken\", accessToken, cookieOptions)\n      .cookie(\"refreshToken\", refreshToken, cookieOptions)\n      .json(new ApiResponse(200, { user: safeUser, accessToken, refreshToken }, \"Google auth successful\"));\n  } catch (e) {\n    throw new ApiError(400, e.message || \"Google auth failed\");\n  }\n});\n\nconst completeOnboarding = asyncHandler(async (req, res) => {\n  const { usn, year, fullname, branch } = req.body || {};\n  if (!usn || !year || !branch) {\n    throw new ApiError(400, \"USN, year and branch are required to complete onboarding\");\n  }\n  const u = await User.findById(req.user._id);\n  if (!u) throw new ApiError(4"},"backend/src/db/server.js":{"path":"backend/src/db/server.js","content":"import mongoose from \"mongoose\";\nimport { DB_NAME } from \"../constants.js\";\nimport { LinkedinPost } from \"../models/linkedinpost.model.js\";\n//import { Opportunity } from \"../models/opportunity.model.js\";\nimport { User } from \"../models/user.model.js\";\n\n\nconst connectDB = async () => {\n    try {\n        const connectionInstance = await mongoose.connect(`${process.env.MONGODB_URI}/${DB_NAME}`,)\n        console.log(`\\n MongoDB connected !! DB HOST: ${connectionInstance.connection.host}`);\n        await User.syncIndexes();\n        await LinkedinPost.syncIndexes();\n        //await Opportunity.syncIndexes();\n        console.log('Indexes synced');\n    } catch (error) {\n        console.log(\"MONGODB connection FAILED \", error);\n        process.exit(1)\n    }\n}\n\nexport default connectDB\n"},"backend/src/job_scarpper/format.py":{"path":"backend/src/job_scarpper/format.py","content":"from flask import Flask, jsonify\r\nimport json\r\n\r\napp = Flask(__name__)\r\n\r\n@app.route(\"/\")\r\ndef home():\r\n    return {\r\n        \"message\": \"Welcome to the CEC Hub API ≡ƒÜÇ\",\r\n        \"endpoints\": {\r\n            \"jobs\": \"/jobs\",\r\n            \"internships\": \"/internships\"\r\n        }\r\n    }\r\n\r\n@app.route(\"/jobs\")\r\ndef get_jobs():\r\n    with open(\"jobs.json\", \"r\") as f:\r\n        jobs = json.load(f)\r\n    return jsonify(jobs)\r\n\r\n@app.route(\"/internships\")\r\ndef get_internships():\r\n    with open(\"internships.json\", \"r\") as f:\r\n        internships = json.load(f)\r\n    return jsonify(internships)\r\n\r\nif __name__ == \"__main__\":\r\n    app.run(debug=True)\r\n"},"backend/src/job_scarpper/job_matching.py":{"path":"backend/src/job_scarpper/job_matching.py","content":"# from sklearn.feature_extraction.text import TfidfVectorizer\n# from sklearn.metrics.pairwise import cosine_similarity\n# import pandas as pd\n\n\n# users = [\n#     {\n#         \"id\": \"u123\",\n#         \"name\": \"Mohith\",\n#         \"skills\": [\"python\", \"machine learning\", \"ai\"],\n#         \"projects\": [\"chatbot\", \"recommendation system\"],\n#         \"certifications\": [\"AWS\", \"TensorFlow\"]\n#     },\n#     {\n#         \"id\": \"u124\",\n#         \"name\": \"Alice\",\n#         \"skills\": [\"python\", \"data science\"],\n#         \"projects\": [\"portfolio website\"],\n#         \"certifications\": [\"Azure\"]\n#     },\n# ]\n\n\n# jobs = [\n#     {\n#         \"id\": \"j101\",\n#         \"title\": \"AI Engineer\",\n#         \"requirements\": [\"python\", \"machine learning\", \"deep learning\", \"TensorFlow\"]\n#     },\n#     {\n#         \"id\": \"j102\",\n#         \"title\": \"Data Analyst\",\n#         \"requirements\": [\"python\", \"sql\", \"data visualization\"]\n#     },\n#     {\n#         \"id\": \"j103\",\n#         \"title\": \"Backend Developer\",\n#         \"requirements\": [\"java\", \"spring boot\", \"mysql\"]\n#     }\n# ]\n\n\n# def profile_to_text(user):\n#     return \" \".join(user[\"skills\"] + user[\"projects\"] + user[\"certifications\"])\n\n\n# def job_to_text(job):\n#     return \" \".join(job[\"requirements\"])\n\n\n# def recommend_jobs(user_id, top_n=3):\n   \n#     user = next((u for u in users if u[\"id\"] == user_id), None)\n#     if not user:\n#         return \"User not found\"\n    \n#     user_text = profile_to_text(user)\n#     job_texts = [job_to_text(j) for j in jobs]\n\n#     vectorizer = TfidfVectorizer()\n#     tfidf_matrix = vectorizer.fit_transform([user_text] + job_texts)\n\n#     similarity_scores = cosine_similarity(tfidf_matrix[0:1], tfidf_matrix[1:]).flatten()\n\n#     ranked_jobs = sorted(\n#         list(zip(jobs, similarity_scores)),\n#         key=lambda x: x[1],\n#         reverse=True\n#     )[:top_n]\n\n#     return [(job[\"title\"], round(score, 2)) for job, score in ranked_jobs]\n\n\n# print(\"Job Recommendations for Mohith:\")\n# print(recommend_jobs(\"u123\"))\n\nimport json\nimport re\nfrom PyPDF2 import PdfReader\n\n# ---------------- PDF Resume Reader ----------------\ndef extract_text_from_pdf(pdf_path):\n    try:\n        reader = PdfReader(pdf_path)\n        text = \"\"\n        for page in reader.pages:\n            text += page.extract_text() + \"\\n\"\n        return text\n    except Exception as e:\n        print(f\"Γ¥î Error reading resume: {e}\")\n        return \"\"\n\n# ---------------- ATS Score Calculator ----------------\ndef calculate_ats_score(resume_text, job):\n    resume_text_lower = resume_text.lower()\n\n    total_keywords = 0\n    matched_keywords = 0\n\n    # High weight: Required skills\n    for skill in job.get(\"skills\", []):\n        total_keywords += 2\n        if skill.lower() in resume_text_lower:\n            matched_keywords += 2\n\n    # Medium weight: Good-to-have\n    for skill in job.get(\"good_to_have\", []):\n        total_keywords += 1\n        if skill.lower() in resume_text_lower:\n            matched_keywords += 1\n\n    # Medium weight: Topics\n    for topic in job.get(\"topics\", []):\n        total_keywords += 1\n        if topic.lower() in resume_text_lower:\n            matched_keywords += 1\n\n    # Low weight: Buzzwords\n    for buzz in job.get(\"buzzwords\", []):\n        total_keywords += 0.5\n        if buzz.lower() in resume_text_lower:\n            matched_keywords += 0.5\n\n    if total_keywords == 0:\n        return 0\n\n    return round((matched_keywords / total_keywords) * 100, 2)\n\n# ---------------- Main ----------------\ndef run_ats(resume_path, jobs_file=\"jobs_output.json\"):\n    # Load resume text\n    resume_text = extract_text_from_pdf(resume_path)\n    if not resume_text:\n        return\n\n    # Load job data\n    try:\n        with open(jobs_file, \"r\", encoding=\"utf-8\") as f:\n            jobs = json.load(f)\n    except Exception as e:\n        print(f\"Γ¥î Error reading jobs file: {e}\")\n        return\n\n    # Calculate ATS scores\n    results = []\n    for job in jobs:\n        score = calculate_ats_score(resume_text, job)\n        results.append({\n            \"title\": job[\"title\"],\n            \"company\": job[\"company\"],\n            \"sco"},"backend/src/job_scarpper/job_scarpper.py":{"path":"backend/src/job_scarpper/job_scarpper.py","content":"import requests\nimport re\nimport os\nfrom dotenv import load_dotenv\n\n\nload_dotenv()\nAPI_KEY = (os.getenv(\"API_KEY\") or \"\").strip()\nif not API_KEY:\n    print(\"Γ¥î Missing API_KEY in .env file\")\n    raise SystemExit(0)\n\nRAPIDAPI_HOST = \"jsearch.p.rapidapi.com\"\nSEEN_JOB_IDS = set()\nBACKEND_URL = (os.getenv(\"BACKEND_URL\") or os.getenv(\"API_BASE_URL\") ).rstrip(\"/\")\nSCRAPER_TOKEN = (os.getenv(\"SCRAPER_TOKEN\") or \"\").strip()\n\n\ndef extract_details_from_description(desc):\n    details = {\n        \"expected_skills\": [],\n        \"good_to_have\": [],\n        \"buzzwords\": [],\n        \"rounds\": None,\n        \"cutoff\": None,\n        \"topics\": []\n    }\n\n    if not desc:\n        return details\n\n    skills_keywords = [\n        \"Python\", \"Java\", \"JavaScript\", \"TypeScript\", \"C\", \"C++\", \"C#\", \"Go\", \"Ruby\", \"PHP\", \"Swift\", \"Kotlin\", \"R\",\n        \"React\", \"Angular\", \"Vue\", \"Next.js\", \"Node.js\", \"Express\", \"HTML\", \"CSS\", \"Bootstrap\", \"Tailwind\",\n        \"SQL\", \"MySQL\", \"PostgreSQL\", \"MongoDB\", \"NoSQL\", \"Oracle\", \"Redis\",\n        \"Machine Learning\", \"Deep Learning\", \"AI\", \"TensorFlow\", \"Keras\", \"PyTorch\",\n        \"AWS\", \"Azure\", \"Google Cloud\",\n        \"Docker\", \"Kubernetes\", \"Terraform\", \"Jenkins\", \"CI/CD\"\n    ]\n    good_to_have_keywords = [\"Leadership\", \"Communication\", \"Teamwork\", \"Problem-solving\", \"Git\"]\n    topics_keywords = [\"Data Structures\", \"Algorithms\", \"OOP\", \"Database\", \"Cloud Computing\"]\n\n    details[\"expected_skills\"] = [skill for skill in skills_keywords if skill.lower() in desc.lower()]\n    details[\"good_to_have\"] = [skill for skill in good_to_have_keywords if skill.lower() in desc.lower()]\n    details[\"topics\"] = [topic for topic in topics_keywords if topic.lower() in desc.lower()]\n\n\n    buzzword_candidates = re.findall(r'\\b[A-Z][a-zA-Z0-9]+\\b', desc)\n    details[\"buzzwords\"] = list(set(buzzword_candidates) - set(details[\"expected_skills\"]))\n\n    rounds_match = re.search(r\"(\\d+)\\s+rounds?\", desc, re.IGNORECASE)\n    if rounds_match:\n        details[\"rounds\"] = rounds_match.group(1)\n\n    cutoff_match = re.search(r\"(\\d+%|\\d+\\.\\d+ CGPA)\", desc, re.IGNORECASE)\n    if cutoff_match:\n        details[\"cutoff\"] = cutoff_match.group(1)\n\n    return details\n\n\n\ndef get_opportunities(query: str, num_pages: int = 1, location: str = \"India\"):\n    url = f\"https://{RAPIDAPI_HOST}/search\"\n    headers = {\n        \"X-RapidAPI-Key\": API_KEY,\n        \"X-RapidAPI-Host\": RAPIDAPI_HOST\n    }\n    params = {\n        \"query\": query,\n        \"page\": \"1\",\n        \"num_pages\": str(num_pages),\n        \"country\": \"in\",  \n        \"location\": location\n    }\n    try:\n        response = requests.get(url, headers=headers, params=params)\n        response.raise_for_status()\n        data = response.json()\n        jobs = data.get(\"data\", [])\n        print(f\"≡ƒôè API returned {len(jobs)} jobs for query='{query}' in location='{location}'\")\n        return jobs\n    except Exception as e:\n        print(f\"Γ¥î Error fetching jobs: {e}\")\n        return []\n\n\ndef _compose_description(item: dict) -> str:\n    \"\"\"Build a human-readable description from raw fields.\"\"\"\n    description = item.get(\"job_description\") or \"\"\n    if description:\n        return description\n    highlights = item.get(\"job_highlights\") or {}\n    quals = highlights.get(\"Qualifications\") or []\n    resp = highlights.get(\"Responsibilities\") or []\n    lines = []\n    if quals:\n        lines.append(\"Qualifications:\")\n        lines.extend(quals)\n        lines.append(\"\")\n    if resp:\n        lines.append(\"Responsibilities:\")\n        lines.extend(resp)\n    return \"\\n\".join(lines).strip()\n\n\ndef build_opportunity(item: dict) -> dict:\n    \"\"\"Map RapidAPI job item to our Opportunity schema payload.\"\"\"\n    job_id = item.get(\"job_id\")\n    title = item.get(\"job_title\", \"N/A\")\n    company = item.get(\"employer_name\", \"N/A\")\n    city = item.get(\"job_city\") or \"\"\n    country = item.get(\"job_country\") or \"\"\n    location = \", \".join([p for p in [city, country] if p]) or (item.get(\"job_country\") or \"N/A\")\n    employment_type = item.get(\"job_employment_type\") or item.get(\"job_employment_type\")\n    remote = \"Yes\" if item.get(\"job_is_remote\", False"},"backend/src/job_scarpper/jobs_output.json":{"path":"backend/src/job_scarpper/jobs_output.json","content":"[\n  {\n    \"job_id\": \"t9Agizunpz-xoHmKAAAAAA==\",\n    \"title\": \"ME00461-Full Stack Developer 4\",\n    \"company\": \"Momentum Engineering, Inc.\",\n    \"location\": \"US\",\n    \"employment_type\": \"Full-time\",\n    \"remote\": \"No\",\n    \"salary\": \"Not specified\",\n    \"posted_on\": \"2025-09-01\",\n    \"skills\": [\n      \"C\",\n      \"R\",\n      \"AI\"\n    ],\n    \"good_to_have\": [\n      \"Git\"\n    ],\n    \"topics\": [\n      \"Database\"\n    ],\n    \"buzzwords\": [\n      \"Momentum\",\n      \"Participate\",\n      \"Primary\",\n      \"Responsibilities\",\n      \"Summary\",\n      \"Engineering\",\n      \"Most\",\n      \"Woman\",\n      \"Small\",\n      \"Confluence\",\n      \"Inc\",\n      \"Owned\",\n      \"IC\",\n      \"Additionally\",\n      \"Our\",\n      \"Define\",\n      \"WOSB\",\n      \"Job\",\n      \"Jira\",\n      \"Business\",\n      \"Candidate\",\n      \"Git\",\n      \"Seeking\",\n      \"Effectively\",\n      \"With\"\n    ],\n    \"rounds\": null,\n    \"cutoff\": null,\n    \"apply_link\": \"https://www.linkedin.com/jobs/view/me00461-full-stack-developer-4-at-momentum-engineering-inc-4293721605?utm_campaign=google_jobs_apply&utm_source=google_jobs_apply&utm_medium=organic\",\n    \"description\": \"Momentum Engineering, Inc., a Woman-Owned Small Business (WOSB), fosters an employee-centric culture. Our strength lies in our people. With a high percentage of employees holding advanced degrees in engineering, computer science, and related disciplines, we bring deep technical expertise to every mission. Our team includes professionals with security clearances and full-scope polygraphs, ensuring trusted, secure support for the most sensitive national security initiatives. Additionally, our workforce is equipped with industry-leading certifications, demonstrating a commitment to continuous learning and excellence. Most importantly, our exceptional employee retention rate reflects a culture of professional growth, mission focus, and dedication\\u2014ensuring long-term stability and expertise for our customers\\u2019 critical needs. Job Summary \\u2022 Seeking a full stack developer who understands both backend and frontend architectures \\u2022 Candidate will maintain, debug, and advance the features of the production system by working effectively as one of several developers on a team \\u2022 Candidate will need to understand how to use Git source control, Jira ticketing for bugs and features, and documentation development on Confluence \\u2022 Candidate should be familiar with most of the technologies listed, but is expected to remain flexible to changes in the technology stack and to learn new skills independently as the needs of the product change over time Primary Responsibilities \\u2022 Define, assign, and resolve bugs, features, and tasks to enhance or maintain a production codebase using Git source code management within an agile software development team \\u2022 Effectively modify backend services, including cloud serverless artifacts and databases, as well as frontend user interface components, to merge quality software into an operational IC system \\u2022 Participate in multiple weekly agile development working sessions to ensure timely releases of bug fixes and new features \\u2022 Participate in peer reviews of\"\n  },\n  {\n    \"job_id\": \"UPk6WG3UpDACE2tgAAAAAA==\",\n    \"title\": \"Full Stack Developer, Mid\",\n    \"company\": \"Booz Allen Hamilton\",\n    \"location\": \"US\",\n    \"employment_type\": \"Full-time\",\n    \"remote\": \"No\",\n    \"salary\": \"Not specified\",\n    \"posted_on\": \"2025-08-28\",\n    \"skills\": [\n      \"Python\",\n      \"Java\",\n      \"C\",\n      \"Go\",\n      \"R\",\n      \"SQL\",\n      \"AI\",\n      \"AWS\",\n      \"Docker\",\n      \"Kubernetes\",\n      \"Jenkins\",\n      \"CI/CD\"\n    ],\n    \"good_to_have\": [\n      \"Git\"\n    ],\n    \"topics\": [\n      \"Database\"\n    ],\n    \"buzzwords\": [\n      \"This\",\n      \"Stack\",\n      \"Secret\",\n      \"R0225211\",\n      \"Rancher\",\n      \"Work\",\n      \"You\",\n      \"Opportunity\",\n      \"Ability\",\n      \"Bachelor\",\n      \"Developer\",\n      \"Gov\",\n      \"UX\",\n      \"Full\",\n      \"UI\",\n      \"Job\",\n      \"Postgres\",\n      \"Booz\",\n      \"Nice\",\n      \"If\",\n      \"Number\",\n      \"Allen\",\n      \"EC2\",\n      \"R"},"backend/src/loadENV.js":{"path":"backend/src/loadENV.js","content":"import dotenv from \"dotenv\"\ndotenv.config({\n    path: './.env'\n})"},"backend/src/middlewares/auth.middleware.js":{"path":"backend/src/middlewares/auth.middleware.js","content":"import { ApiError } from \"../utils/apierrorhandler.js\";\nimport { asyncHandler } from \"../utils/asynchandler.js\";\nimport jwt from \"jsonwebtoken\"\nimport { User } from \"../models/user.model.js\";\n\nexport const verifyJWT = asyncHandler(async(req, _, next) => {\n    try {\n        const token = req.cookies?.accessToken || req.header(\"Authorization\")?.replace(\"Bearer \", \"\")\n       \n        if (!token) {\n            throw new ApiError(401, \"Unauthorized request\")\n        }\n    \n        const decodedToken = jwt.verify(token, process.env.ACCESS_TOKEN_SECRET)\n    \n        const user = await User.findById(decodedToken?._id).select(\"-password -refreshToken\")\n    \n        if (!user) {\n            \n            throw new ApiError(401, \"Invalid Access Token\")\n        }\n    \n        req.user = user;\n        next()\n    } catch (error) {\n        throw new ApiError(401, error?.message || \"Invalid access token\")\n    }\n    \n})\n\nexport const requireAdmin = asyncHandler(async (req, _res, next) => {\n    if (!req.user || !req.user.isAdmin) {\n        throw new ApiError(403, 'Admin privileges required');\n    }\n    next();\n});"},"backend/src/middlewares/cache.middleware.js":{"path":"backend/src/middlewares/cache.middleware.js","content":"import { createHash } from \"crypto\";\n\nclass LruTtlCache {\n  constructor(maxEntries = 500) {\n    this.maxEntries = maxEntries;\n    this.map = new Map();\n  }\n\n  _now() {\n    return Date.now();\n  }\n\n  get(key) {\n    const entry = this.map.get(key);\n    if (!entry) return null;\n    if (entry.expiresAt <= this._now()) {\n      this.map.delete(key);\n      return null;\n    }\n    this.map.delete(key);\n    this.map.set(key, entry);\n    return entry;\n  }\n\n  set(key, value, ttlMs) {\n    const expiresAt = this._now() + ttlMs;\n    if (this.map.has(key)) this.map.delete(key);\n    this.map.set(key, { ...value, expiresAt });\n    while (this.map.size > this.maxEntries) {\n      const oldestKey = this.map.keys().next().value;\n      this.map.delete(oldestKey);\n    }\n  }\n}\n\nconst globalCache = new LruTtlCache(500);\n\nfunction buildKey(req) {\n  return `${req.method}:${req.originalUrl}`;\n}\n\nfunction computeETag(bodyBuffer) {\n  const hash = createHash(\"sha1\").update(bodyBuffer).digest(\"hex\");\n  return `\"${hash}\"`;\n}\n\nfunction cacheMiddleware({ ttlSeconds = 60, privacy = \"public\" } = {}) {\n  const ttlMs = Math.max(1, ttlSeconds) * 1000;\n  const cacheControl =\n    privacy === \"private\"\n      ? `private, max-age=${ttlSeconds}`\n      : `public, max-age=${ttlSeconds}, s-maxage=${ttlSeconds}`;\n\n  return function (req, res, next) {\n    if (req.method !== \"GET\") return next();\n\n    const key = buildKey(req);\n    const cached = globalCache.get(key);\n    if (cached) {\n      if (\n        req.headers[\"if-none-match\"] &&\n        req.headers[\"if-none-match\"] === cached.etag\n      ) {\n        res.setHeader(\"ETag\", cached.etag);\n        res.setHeader(\"Cache-Control\", cacheControl);\n        return res.status(304).end();\n      }\n      res.setHeader(\n        \"Content-Type\",\n        cached.contentType || \"application/json; charset=utf-8\"\n      );\n      res.setHeader(\"ETag\", cached.etag);\n      res.setHeader(\"Cache-Control\", cacheControl);\n      return res.status(cached.statusCode || 200).send(cached.body);\n    }\n\n    const originalJson = res.json.bind(res);\n    const originalSend = res.send.bind(res);\n\n    function captureAndSend(body, sender) {\n      try {\n        let buffer;\n        if (Buffer.isBuffer(body)) buffer = body;\n        else if (typeof body === \"string\") buffer = Buffer.from(body);\n        else buffer = Buffer.from(JSON.stringify(body));\n\n        const etag = computeETag(buffer);\n\n        if (\n          req.headers[\"if-none-match\"] &&\n          req.headers[\"if-none-match\"] === etag\n        ) {\n          res.setHeader(\"ETag\", etag);\n          res.setHeader(\"Cache-Control\", cacheControl);\n          return res.status(304).end();\n        }\n\n        res.setHeader(\"ETag\", etag);\n        res.setHeader(\"Cache-Control\", cacheControl);\n\n        const contentType = res.getHeader(\"Content-Type\");\n        const statusCode = res.statusCode;\n\n        globalCache.set(\n          key,\n          { body: buffer, etag, contentType, statusCode },\n          ttlMs\n        );\n      } catch (e) {}\n      return sender(body);\n    }\n\n    res.json = (body) => captureAndSend(body, originalJson);\n    res.send = (body) => captureAndSend(body, originalSend);\n\n    next();\n  };\n}\n\nexport function publicCache(ttlSeconds = 60) {\n  return cacheMiddleware({ ttlSeconds, privacy: \"public\" });\n}\n\nexport function privateCache(ttlSeconds = 60) {\n  return cacheMiddleware({ ttlSeconds, privacy: \"private\" });\n}\n"},"backend/src/middlewares/multer.middleware.js":{"path":"backend/src/middlewares/multer.middleware.js","content":"import multer from \"multer\";\nconst storage = multer.diskStorage({\n    destination: function (req, file, cb) {\n      cb(null, \"./public/temp\")\n    },\n    filename: function (req, file, cb) {\n      \n      cb(null, file.originalname)\n      //You can also use a custom naming convention here it should be unique but here it is not needed mandatory\n      // cb(null, Date.now() + '-' + file.originalname)\n    }\n  })\n  \nexport const upload = multer({ \n    storage, \n})"},"backend/src/models/chatroom.model.js":{"path":"backend/src/models/chatroom.model.js","content":"import mongoose from \"mongoose\";\n\nconst chatRoomSchema = new mongoose.Schema(\n  {\n    name: { type: String, required: true, trim: true },\n    members: [{ type: mongoose.Schema.Types.ObjectId, ref: \"User\" }],\n    isPrivate: { type: Boolean, default: false },\n  },\n  { timestamps: true }\n);\n\nexport const ChatRoom = mongoose.model(\"ChatRoom\", chatRoomSchema);\n"},"backend/src/models/competition.model.js":{"path":"backend/src/models/competition.model.js","content":"import mongoose from \"mongoose\";\n\nconst CompetitionSchema = new mongoose.Schema({\n    title: {\n        type: String,\n        required: true\n    },\n    description: {\n        type: String,\n        required: true\n    },\n    teamsize: {\n        type : String\n    },\n    Prize:{\n        type: String,\n        default:0\n    },\n    startDate: {\n        type: String,\n        required: true\n    },\n    Tag:{\n        type: String,\n        required:true\n    },\n    Reqirements:{\n        type:String,\n        required:true\n   },\n   \n    endDate: {\n        type: String,\n        required: true\n    },\n    link: {\n        type: String,\n        required: true\n    },\n    coverImage: {\n        type: String\n    },\n    isTeamEvent: {\n        type: Boolean,\n        default: false\n    },\n    aplliedBy: [{\n        type: mongoose.Schema.Types.ObjectId,\n        ref: \"User\"\n    }],\n    applicationCount: {\n        type: Number,\n        default: 0\n    }\n\n\n}, { timestamps: true });\n\nexport const Competition = mongoose.model(\"Competition\", CompetitionSchema);\n"},"backend/src/models/contest.model.js":{"path":"backend/src/models/contest.model.js","content":"import mongoose from \"mongoose\";\n\nconst contestSchema = new mongoose.Schema(\n  {\n    title: { type: String, required: true, trim: true },\n    description: { type: String, required: true },\n    startAt: { type: Date, required: true, index: true },\n    endAt: { type: Date, required: true, index: true },\n    problems: [{ type: mongoose.Schema.Types.ObjectId, ref: \"Problem\" }],\n    createdBy: { type: mongoose.Schema.Types.ObjectId, ref: \"User\", required: true },\n    visibility: { type: String, enum: [\"public\", \"private\"], default: \"public\", index: true }\n  },\n  { timestamps: true }\n);\n\nexport const Contest = mongoose.model(\"Contest\", contestSchema);\n"},"backend/src/models/follower.model.js":{"path":"backend/src/models/follower.model.js","content":"import mongoose,{Schema} from \"mongoose\";\nconst followerSchema = new mongoose.Schema({\n    Follower: {\n        type: mongoose.Schema.Types.ObjectId,\n        ref: \"User\"\n    },\n    Following: {\n        type: mongoose.Schema.Types.ObjectId,\n        ref: \"User\"\n    },\n}, {\n  timestamps: true});\nexport const Follower = mongoose.model(\"Follower\", followerSchema);\n"},"backend/src/models/github.model.js":{"path":"backend/src/models/github.model.js","content":"import mongoose, { Schema } from \"mongoose\";\nconst githubStatsSchema = new Schema(\n    {\n    user: {\n      type: Schema.Types.ObjectId,\n      ref: \"User\",\n      required: true,\n      unique: true, \n    },\n    username: {\n      type: String,\n      required: true,\n      unique: true,\n    },\n    totalContributions: {\n      type: Number,\n      default: 0,\n    },\n    thisYearContributions: {\n      type: Number,\n      default: 0,\n    },\n    lastMonthContributions: {\n        type: Number,\n        default: 0,\n    },\n    thisMonthContributions: {\n        type: Number,\n        default: 0,\n    },\n    todayContributions: {\n      type: Number,\n      default: 0,\n    },\n    languages: {\n      type: Object,\n      default: {},\n      description: \"Object containing language names as keys and byte counts as values\"\n    },\n    topLanguage: {\n      type: String,\n      default: \"\",\n      description: \"Most used language by the user\"\n    },\n    lastUpdated: {\n      type: Date,\n      default: Date.now,\n    },\n  },\n  { timestamps: true }\n);\n\nexport const GithubStats = mongoose.model(\"GithubStats\", githubStatsSchema);\n"},"backend/src/models/leetcode.model.js":{"path":"backend/src/models/leetcode.model.js","content":"import mongoose from \"mongoose\";\n\nconst leetcodeStatsSchema = new mongoose.Schema({\n  user: {\n    type: mongoose.Schema.Types.ObjectId,\n    ref: \"User\",\n    required: true,\n    unique: true\n  },\n  username: {\n    type: String,\n    required: true\n  },\n  ranking: {\n    type: Number,\n    required: true\n  },\n  totalSolved: Number,\n  easySolved: Number,\n  mediumSolved: Number,\n  hardSolved: Number,\n  acceptanceRate: Number,\n  contributionPoints: Number,\n  reputation: Number,\n  submissionCalendar: Object,\n  languages: {\n    type: Object,\n    default: {},\n    description: \"Object containing language names as keys and submission counts as values\"\n  },\n  topLanguage: {\n    type: String,\n    default: \"\",\n    description: \"Most used language by the user for solving problems\"\n  },\n  lastUpdated: {\n    type: Date,\n    default: Date.now\n  }\n});\n\nexport const LeetcodeStats = mongoose.model(\"LeetcodeStats\", leetcodeStatsSchema);\n"},"backend/src/models/linkedinpost.model.js":{"path":"backend/src/models/linkedinpost.model.js","content":"import mongoose from \"mongoose\";\n\nconst linkedinPostSchema = new mongoose.Schema({\n    owner: {\n        type: mongoose.Schema.Types.ObjectId,\n        ref: \"User\",\n        required: true,\n    },\n    url: { type: String, required: true },\n    text: { type: String },\n    images: [{ value: String }],\n    createdAt: { type: Date, default: Date.now },\n});\nlinkedinPostSchema.index({ owner: 1, text: 1 }, { unique: true });\nexport const LinkedinPost = mongoose.model(\"LinkedinPost\", linkedinPostSchema);"},"backend/src/models/mentor.model.js":{"path":"backend/src/models/mentor.model.js","content":"import mongoose from 'mongoose';\n\nconst mentorSchema = new mongoose.Schema({\n  name: { type: String, required: true, trim: true },\n  year: { type: String },\n  specialization: { type: String, required: true },\n  bio: { type: String },\n  skills: [{ type: String, trim: true }],\n  rating: { type: Number, default: 0 },\n  totalReviews: { type: Number, default: 0 },\n  mentees: { type: Number, default: 0 },\n  projects: { type: Number, default: 0 },\n  sessionsCompleted: { type: Number, default: 0 },\n  responseTime: { type: String },\n  avatar: { type: String },\n  available: { type: Boolean, default: false },\n  nextAvailable: { type: String },\n  hourlyRate: { type: String, default: 'Free' },\n  languages: [{ type: String, trim: true }],\n  achievements: [{ type: String }],\n  experience: { type: String },\n  company: { type: String },\n  location: { type: String },\n  joinedDate: { type: Date, default: Date.now },\n  sessionTypes: [{ type: String }],\n  expertise: [{ type: String }],\n}, { timestamps: true });\n\nexport const Mentor = mongoose.model('Mentor', mentorSchema);\n"},"backend/src/models/mentorApplication.model.js":{"path":"backend/src/models/mentorApplication.model.js","content":"import mongoose from 'mongoose';\n\nconst mentorApplicationSchema = new mongoose.Schema({\n  fullName: { type: String, required: true, trim: true },\n  email: { type: String, required: true, lowercase: true, trim: true },\n  phone: { type: String },\n  linkedin: { type: String },\n  github: { type: String },\n  portfolio: { type: String },\n  specialization: { type: String, required: true },\n  expertise: [{ type: String }],\n  experienceYears: { type: String },\n  availability: { type: String },\n  whySuitable: { type: String, required: true },\n  page: { type: String },\n  sent_at: { type: Date },\n  status: { type: String, enum: ['pending', 'approved', 'rejected'], default: 'pending' }\n}, { timestamps: true });\n\nexport const MentorApplication = mongoose.model('MentorApplication', mentorApplicationSchema);\n"},"backend/src/models/message.model.js":{"path":"backend/src/models/message.model.js","content":"import mongoose from \"mongoose\";\n\nconst messageSchema = new mongoose.Schema(\n  {\n    sender: { type: mongoose.Schema.Types.ObjectId, ref: \"User\", required: true },\n    roomId: { type: mongoose.Schema.Types.ObjectId, ref: \"ChatRoom\", default: null },\n    receiverUser: { type: mongoose.Schema.Types.ObjectId, ref: \"User\", default: null },\n    content: { type: String, required: true },\n    type: { type: String, enum: [\"text\", \"image\", \"video\"], default: \"text\" },\n    replyTo: { type: mongoose.Schema.Types.ObjectId, ref: \"Message\", default: null },\n    reactions: {\n      type: Map,\n      of: [{ type: mongoose.Schema.Types.ObjectId, ref: \"User\" }],\n      default: {},\n    },\n    pinned: { type: Boolean, default: false },\n  },\n  { timestamps: true }\n);\n\nmessageSchema.index({ roomId: 1, createdAt: -1 });\nmessageSchema.index({ sender: 1, receiverUser: 1, createdAt: -1 });\nmessageSchema.index({ replyTo: 1 });\n\nexport const Message = mongoose.model(\"Message\", messageSchema);\n"},"backend/src/models/opportunity.model.js":{"path":"backend/src/models/opportunity.model.js","content":"import mongoose from \"mongoose\";\n\nconst OpportunitySchema = new mongoose.Schema(\n  {\n    job_id: { type: String, required: true, unique: true, index: true },\n    title: { type: String, required: true },\n    company: { type: String },\n    location: { type: String },\n    employment_type: { type: String },\n    remote: { type: String },\n    salary: { type: String },\n    posted_on: { type: String },\n    skills: [{ type: String }],\n    good_to_have: [{ type: String }],\n    topics: [{ type: String }],\n    buzzwords: [{ type: String }],\n    rounds: { type: String },\n    cutoff: { type: String },\n    apply_link: { type: String },\n    description: { type: String },\n    type: { type: String, enum: [\"job\", \"internship\"], index: true },\n  },\n  { timestamps: true }\n);\n\nexport const Opportunity = mongoose.model(\"Opportunity\", OpportunitySchema);\n"},"backend/src/models/post.model.js":{"path":"backend/src/models/post.model.js","content":"import e from \"express\";\nimport mongoose from \"mongoose\";\nimport mongooseAggregatePaginate from \"mongoose-aggregate-paginate-v2\";\nconst postSchema = new mongoose.Schema({\n   postId: {\n    type: String,\n    unique: true,\n    default: () => new mongoose.Types.ObjectId().toString()\n  },\n  postFile: [{\n      type: String,\n      required: true\n    }],\n  description: {\n    type: String,\n    required: true\n  },\n  liveLink: {\n    type: String,\n    required: false\n  },\n  githubLink: {\n    type: String,\n    required: false\n  },\n views: {\n    type: Number,\n    default: 0\n  },\n  ispublished: {\n    type: Boolean,\n    default: true\n  },\n owner: {\n    type: mongoose.Schema.Types.ObjectId,  \n    ref: \"User\",\n    required: true\n    },\n    tags: [{\n        type: String,\n        trim: true\n        }],\n    likes: [{\n        type: mongoose.Schema.Types.ObjectId,\n        ref: \"User\"\n        }],\n  comments: [{\n    user: {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: \"User\",\n      required: true\n    },\n    comment: {\n      type: String,\n      required: true,\n      trim: true\n    },\n    createdAt: {\n      type: Date,\n      default: Date.now\n    },\n    commentlikes: [{\n      type: mongoose.Schema.Types.ObjectId,\n        ref: \"User\"\n  }]\n    }]\n},\n{ timestamps: true }\n);\n\npostSchema.plugin(mongooseAggregatePaginate);\nexport const Post = mongoose.model(\"Post\", postSchema);"},"backend/src/models/problem.model.js":{"path":"backend/src/models/problem.model.js","content":"import mongoose from \"mongoose\";\n\nconst sampleSchema = new mongoose.Schema(\n  {\n    input: { type: String, default: \"\" },\n    output: { type: String, default: \"\" }\n  },\n  { _id: false }\n);\n\nconst testCaseSchema = new mongoose.Schema(\n  {\n    input: { type: String, default: \"\" },\n    output: { type: String, default: \"\" },\n    isHidden: { type: Boolean, default: true }\n  },\n  { _id: false }\n);\n\nconst problemSchema = new mongoose.Schema(\n  {\n    title: { type: String, required: true, trim: true },\n    statement: { type: String, required: true },\n    inputFormat: { type: String },\n    outputFormat: { type: String },\n    constraints: { type: String },\n    samples: [sampleSchema],\n    testCases: [testCaseSchema],\n    allowedLangs: [{ type: Number }], \n    timeLimit: { type: Number, default: 2.0 }, \n    memoryLimit: { type: Number, default: 128000 } \n  },\n  { timestamps: true }\n);\n\nexport const Problem = mongoose.model(\"Problem\", problemSchema);\n"},"backend/src/models/submission.model.js":{"path":"backend/src/models/submission.model.js","content":"import mongoose from \"mongoose\";\n\nconst submissionSchema = new mongoose.Schema(\n  {\n    user: { type: mongoose.Schema.Types.ObjectId, ref: \"User\", required: true, index: true },\n    contest: { type: mongoose.Schema.Types.ObjectId, ref: \"Contest\", required: true, index: true },\n    problem: { type: mongoose.Schema.Types.ObjectId, ref: \"Problem\", required: true, index: true },\n    languageId: { type: Number, required: true },\n    sourceCode: { type: String, required: true },\n    verdict: { type: String, enum: [\"Accepted\", \"Wrong Answer\", \"Time Limit Exceeded\", \"Runtime Error(SIGSEGV)\",\"Runtime Error(SIGXFSZ)\",\"Runtime Error(SIGFPE)\",\"Runtime Error(SIGABRT)\", \"Runtime Error(NZEC)\",\"Runtime Error(Other)\",\"Runtime Error(Exec format error)\",\"Compilation Error\", \"Internal Error\"], default: \"IE\", index: true },\n    passed: { type: Number, default: 0 },\n    total: { type: Number, default: 0 },\n    execTimeMs: { type: Number, default: 0 },\n    stderr: { type: String },\n    stdout: { type: String }\n  },\n  { timestamps: true }\n);\n\nsubmissionSchema.index({ contest: 1, user: 1, problem: 1, createdAt: 1 });\n\nexport const Submission = mongoose.model(\"Submission\", submissionSchema);\n"},"backend/src/models/team.model.js":{"path":"backend/src/models/team.model.js","content":"import mongoose from \"mongoose\";\n\nconst TeamSchema = new mongoose.Schema({\n    name: {\n        type: String,\n        required: true,\n        trim: true\n    },\n    competition: {\n        type: mongoose.Schema.Types.ObjectId,\n        ref: \"Competition\",\n        required: true\n    },\n    leader: {\n        type: mongoose.Schema.Types.ObjectId,\n        ref: \"User\",\n        required: true\n    },\n    members: [{\n        type: mongoose.Schema.Types.ObjectId,\n        ref: \"User\"\n    }],\n    invitationLinks: [{\n        code: {\n            type: String,\n            required: true\n        },\n        expiresAt: {\n            type: Date,\n            required: true\n        },\n        isActive: {\n            type: Boolean,\n            default: true\n        }\n    }],\n    pendingRequests: [{\n        user: {\n            type: mongoose.Schema.Types.ObjectId,\n            ref: \"User\"\n        },\n        requestedAt: {\n            type: Date,\n            default: Date.now\n        }\n    }],\n    maxMembers: {\n        type: Number,\n        default: 4\n    }\n}, { timestamps: true });\nTeamSchema.index({ name: 1, competition: 1 }, { unique: true });\n\nexport const Team = mongoose.model(\"Team\", TeamSchema);"},"backend/src/models/user.model.js":{"path":"backend/src/models/user.model.js","content":"import mongoose from \"mongoose\";\nimport jwt from \"jsonwebtoken\";\nimport bcrypt from \"bcrypt\";\n\nconst userSchema = new mongoose.Schema({\n  fullname: {\n    type: String,\n    required: true,\n    unique: true,\n    index: true,\n    trim: true\n  },\n  usn: {\n    type: String,\n    required: function () { return this.onboardingCompleted === true || this.provider === 'local'; },\n    trim: true,\n    set: function(v) { return typeof v === 'string' ? v.trim().toUpperCase() : v; },\n    match: [/^4CB/, 'Invalid USN.']\n  },\n  year: {\n    type: Number,\n    required: function () { return this.onboardingCompleted === true || this.provider === 'local'; }\n  },\n  branch: {\n    type: String,\n    enum: ['CSE', 'ISE', 'AIML', 'CSD', 'CSBS', 'ECE'],\n    required: function () { return this.onboardingCompleted === true || this.provider === 'local'; },\n    set: function(v) { return typeof v === 'string' ? v.trim().toUpperCase() : v; }\n  },\n  email: {\n    type: String,\n    required: true,\n    unique: true,\n    index: true,\n    lowercase: true,\n    trim: true\n  },\n  password: {\n    type: String,\n    required: function () { return this.provider === 'local'; }\n  },\n  avatar: {\n    type: String,\n    default: \"/default_avatar.png\"\n  },\n  coverimage: {\n    type: String,\n    default: \"/default_coverimage.jpg\"\n  },\n  provider: {\n    type: String,\n    enum: ['local', 'google'],\n    default: 'local'\n  },\n  googleId: {\n    type: String,\n    index: true,\n    sparse: true\n  },\n  onboardingCompleted: {\n    type: Boolean,\n    default: false\n  },\n  likehistory: [{\n    type: mongoose.Schema.Types.ObjectId,\n    ref: \"Post\"\n  }],\n  Commenthistory: [{\n    type: mongoose.Schema.Types.ObjectId,\n    ref: \"Post\"\n  }],\n  followers: [{\n    type: mongoose.Schema.Types.ObjectId,\n    ref: \"User\"\n  }],\n  following: [{\n    type: mongoose.Schema.Types.ObjectId,\n    ref: \"User\"\n  }],\n  isVerified: {\n    type: Boolean,\n    default: false\n  },\n  linkedin: {\n    type: String\n  },\n  github: {\n    type: String\n  },\n  leetcode: {\n    type: String\n  },\n  certifications: [{\n    title: { type: String, required: true },\n    issuer: { type: String },\n    date: { type: Date, default: Date.now }\n  }],\n  projects: [{\n    title: { type: String, required: true },\n    description: { type: String },\n    link: { type: String },\n    date: { type: Date, default: Date.now }\n  }],\n  skills: [{\n    type: String,\n    trim: true\n  }],\n  followRequests: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],\n  notifications: [{\n    type: { type: String, enum: ['follow-request', 'other'], default: 'follow-request' },\n    from: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },\n    date: { type: Date, default: Date.now },\n    read: { type: Boolean, default: false }\n  }],\n  bio: {\n    type: String,\n    trim: true\n  },\n  achievements: [{\n    title: { type: String, required: true },\n    description: { type: String },\n    date: { type: Date, default: Date.now }\n  }],\n  otherLinks: [{\n    title: { type: String, required: true },\n    url: { type: String, required: true }\n  }],\n  isAdmin: {\n    type: Boolean,\n    default: false\n  },\n  refreshToken: {\n    type: String\n  },\n\n\n},\n  {\n    timestamps: true\n  });\nuserSchema.pre(\"save\", async function (next) {\n  if (this.isModified(\"password\") && this.password) {\n    this.password = await bcrypt.hash(this.password, 10)\n  }\n  next()\n})\nuserSchema.methods.isPasswordCorrect = async function (password) {\n  return await bcrypt.compare(password, this.password)\n}\nuserSchema.methods.generateAccessToken = function () {\n  return jwt.sign({ _id: this._id }, process.env.ACCESS_TOKEN_SECRET, { expiresIn: process.env.ACCESS_TOKEN_EXPIRY })\n}\nuserSchema.methods.generateRefreshToken = function () {\n  return jwt.sign({ _id: this._id }, process.env.REFRESH_TOKEN_SECRET, { expiresIn: process.env.REFRESH_TOKEN_EXPIRY })\n}\nuserSchema.index(\n  { usn: 1 },\n  { unique: true, partialFilterExpression: { usn: { $type: 'string' } } }\n);\n\nexport const User = mongoose.model(\"User\", userSchema)"},"backend/src/reccomondation system/reccomondatio.py":{"path":"backend/src/reccomondation system/reccomondatio.py","content":"from sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics.pairwise import cosine_similarity\nimport pandas as pd\n\n\nusers = [\n    {\n        \"id\": \"u123\",\n        \"name\": \"Mohith\",\n        \"skills\": [\"python\", \"machine learning\", \"ai\"],\n        \"projects\": [\"chatbot\", \"recommendation system\"],\n        \"certifications\": [\"AWS\", \"TensorFlow\"]\n    },\n    {\n        \"id\": \"u124\",\n        \"name\": \"Alice\",\n        \"skills\": [\"python\", \"data science\"],\n        \"projects\": [\"portfolio website\"],\n        \"certifications\": [\"Azure\"]\n    },\n    {\n        \"id\": \"u125\",\n        \"name\": \"Bob\",\n        \"skills\": [\"java\", \"spring boot\"],\n        \"projects\": [\"ecommerce app\"],\n        \"certifications\": [\"Oracle\"]\n    },\n    {\n        \"id\": \"u126\",\n        \"name\": \"Charlie\",\n        \"skills\": [\"python\", \"ai\"],\n        \"projects\": [\"chatbot\"],\n        \"certifications\": [\"AWS\"]\n    }\n]\n\n\ndef profile_to_text(user):\n    return \" \".join(user[\"skills\"] + user[\"projects\"] + user[\"certifications\"])\n\nuser_ids = [u[\"id\"] for u in users]\nprofiles = [profile_to_text(u) for u in users]\n\n\nvectorizer = TfidfVectorizer()\ntfidf_matrix = vectorizer.fit_transform(profiles)\n\n\nsimilarity_matrix = cosine_similarity(tfidf_matrix)\n\n\ndef recommend(user_id, top_n=3):\n    if user_id not in user_ids:\n        return \"User not found\"\n    idx = user_ids.index(user_id)\n    sim_scores = list(enumerate(similarity_matrix[idx]))\n    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)\n    sim_scores = sim_scores[1:top_n+1]  # skip self\n\n    recommendations = [(users[i][\"name\"], round(score, 2)) for i, score in sim_scores]\n    return recommendations\n\n\nprint(\"Recommendations for Mohith:\")\nprint(recommend(\"u123\"))\n"},"backend/src/routes/activity.routes.js":{"path":"backend/src/routes/activity.routes.js","content":"import express from 'express';\nimport { getGithubActivity, getLeetcodeActivity } from '../controllers/activity.controller.js';\nimport { verifyJWT } from '../middlewares/auth.middleware.js';\n\nconst router = express.Router();\n\nrouter.use(verifyJWT);\n\nrouter.get('/github/:userId', getGithubActivity);\nrouter.get('/leetcode/:userId', getLeetcodeActivity);\n\nexport default router;"},"backend/src/routes/chat.router.js":{"path":"backend/src/routes/chat.router.js","content":"import { Router } from \"express\";\nimport { verifyJWT } from \"../middlewares/auth.middleware.js\";\nimport { upload } from \"../middlewares/multer.middleware.js\";\nimport {\n  listRooms,\n  getRoomMessages,\n  getPrivateMessages,\n  uploadChatFile,\n  getPrivateContacts,\n  getOrCreateChatThread,\n  reactToMessage,\n  pinMessage,\n  unpinMessage,\n} from \"../controllers/chat.controller.js\";\n\nconst router = Router();\nrouter.get(\"/rooms\", verifyJWT, listRooms);\nrouter.get(\"/rooms/:roomId/messages\", verifyJWT, getRoomMessages);\n\nrouter.get(\"/private/:userId/messages\", verifyJWT, getPrivateMessages);\nrouter.get(\"/private/contacts\", verifyJWT, getPrivateContacts);\nrouter.get(\"/private/:userId/thread\", verifyJWT, getOrCreateChatThread);\n\nrouter.post(\"/messages/:messageId/react\", verifyJWT, reactToMessage);\nrouter.post(\"/messages/:messageId/pin\", verifyJWT, pinMessage);\nrouter.post(\"/messages/:messageId/unpin\", verifyJWT, unpinMessage);\n\nrouter.post(\"/upload\", verifyJWT, upload.single(\"file\"), uploadChatFile);\n\nexport default router;\n"},"backend/src/routes/chatbot.router.js":{"path":"backend/src/routes/chatbot.router.js","content":"import express from 'express';\nimport axios from 'axios';\n\nconst router = express.Router();\n\n\nrouter.post('/chat', async (req, res) => {\n  try {\n    const { message } = req.body || {};\n    if (typeof message !== 'string' || !message.trim()) {\n      return res.status(400).json({ success: false, message: 'message is required' });\n    }\n\n    const target = process.env.CHATBOT_URL || 'http://127.0.0.1:5000/chat';\n    const timeoutMs = parseInt(process.env.CHATBOT_TIMEOUT_MS || '60000', 10);\n    const maxAttempts = parseInt(process.env.CHATBOT_MAX_ATTEMPTS || '2', 10);\n    const backoffMs = parseInt(process.env.CHATBOT_BACKOFF_MS || '3000', 10);\n\n    let lastErr = null;\n    for (let attempt = 1; attempt <= Math.max(1, maxAttempts); attempt++) {\n      try {\n        if (process.env.NODE_ENV !== 'production') {\n          console.log(`[ChatbotProxy] Attempt ${attempt}/${maxAttempts} -> ${target}`);\n        }\n        const response = await axios.post(\n          target,\n          { message },\n          { timeout: timeoutMs, headers: { 'Content-Type': 'application/json' } }\n        );\n        if (response && response.data) {\n          return res.json(response.data);\n        }\n        lastErr = new Error('Invalid response body');\n      } catch (e) {\n        lastErr = e;\n        if (attempt < maxAttempts) {\n          await new Promise((r) => setTimeout(r, backoffMs * attempt));\n          continue;\n        }\n      }\n    }\n\n    return res.status(502).json({ success: false, message: 'Invalid response from chatbot service', detail: lastErr?.message || lastErr });\n  } catch (err) {\n    const status = err?.response?.status || 502;\n    const detail = err?.response?.data || err?.message || 'Chatbot service error';\n    if (process.env.NODE_ENV !== 'production') {\n      console.error('[ChatbotProxy]', detail);\n    }\n    return res.status(status).json({ success: false, message: 'Chatbot service unavailable', detail });\n  }\n});\n\n// Simple health check that posts a lightweight ping to the chatbot service.\nrouter.get('/health', async (req, res) => {\n  try {\n    const target = process.env.CHATBOT_URL || 'http://127.0.0.1:5000/chat';\n    const timeoutMs = parseInt(process.env.CHATBOT_HEALTH_TIMEOUT_MS || '8000', 10);\n    const resp = await axios.post(target, { message: 'ping' }, { timeout: timeoutMs });\n    return res.json({ ok: true, reply: resp?.data?.reply ?? null });\n  } catch (e) {\n    return res.status(502).json({ ok: false, error: e?.message || e });\n  }\n});\n\nexport default router;\n"},"backend/src/routes/competition.router.js":{"path":"backend/src/routes/competition.router.js","content":"import { Router } from \"express\";\nimport { verifyJWT, requireAdmin } from \"../middlewares/auth.middleware.js\";\nimport { createCompetition, listCompetitions, getCompetitionDetails, deleteCompetition, applyToCompetition, verifyParticipant } from \"../controllers/competition.controller.js\";\nimport { upload } from \"../middlewares/multer.middleware.js\";\n\n\nconst router = Router();\n\n\nrouter.route(\"/create\").post(\n    upload.fields([\n        { name: \"coverImage\", maxCount: 1 }\n    ]),\n    verifyJWT, requireAdmin, createCompetition);\nrouter.get(\"/\", listCompetitions);\n\nrouter.get(\"/:id/details\", verifyJWT, getCompetitionDetails);\nrouter.delete(\"/:id/delete\", verifyJWT, requireAdmin, deleteCompetition);\nrouter.post(\"/:id/apply\", verifyJWT, applyToCompetition);\nrouter.post(\"/verify-participant\", verifyJWT, requireAdmin, verifyParticipant);\n\nexport default router;"},"backend/src/routes/contest.router.js":{"path":"backend/src/routes/contest.router.js","content":"import { Router } from \"express\";\nimport { verifyJWT, requireAdmin } from \"../middlewares/auth.middleware.js\";\nimport {\n  createContest,\n  listContests,\n  getContest,\n  addProblem,\n  getProblem,\n  submitSolution,\n  getLeaderboard,\n  listProblems,\n  attachExistingProblem,\n  attachExistingProblemsBulk,\n  runCustomTest,\n  getMyProblemStatus,\n  getUserSubmissions\n} from \"../controllers/contest.controller.js\";\n\nconst router = Router();\n\nrouter.get(\"/\", listContests);\nrouter.post(\"/\", verifyJWT, requireAdmin, createContest);\nrouter.get(\"/problems\", verifyJWT, requireAdmin, listProblems);\nrouter.get(\"/:id\", getContest);\n\nrouter.post(\"/:contestId/problems\", verifyJWT, requireAdmin, addProblem);\nrouter.get(\"/:contestId/problems/:problemId\", verifyJWT, getProblem);\nrouter.post(\"/:contestId/problems/:problemId/attach\", verifyJWT, requireAdmin, attachExistingProblem);\nrouter.post(\"/:contestId/problems/attach-bulk\", verifyJWT, requireAdmin, attachExistingProblemsBulk);\nrouter.post(\"/:contestId/problems/:problemId/run\", verifyJWT, runCustomTest);\nrouter.get(\"/:contestId/problems/:problemId/my-status\", verifyJWT, getMyProblemStatus);\n\nrouter.post(\"/:contestId/problems/:problemId/submit\", verifyJWT, submitSolution);\nrouter.get(\"/:contestId/leaderboard\", getLeaderboard);\nrouter.get(\"/:contestId/users/:userId/submissions\", verifyJWT, getUserSubmissions);\n\nexport default router;\n"},"backend/src/routes/leaderboard.router.js":{"path":"backend/src/routes/leaderboard.router.js","content":"import { Router } from \"express\";\nimport { verifyJWT } from \"../middlewares/auth.middleware.js\";\nconst router= Router()\nimport {getGithubLeaderboard  } from \"../controllers/githubleaderboard.controller.js\";\nimport { getLeetcodeLeaderboard} from \"../controllers/leetcodeleaderboard.controller.js\";\nimport { privateCache } from \"../middlewares/cache.middleware.js\";\n\nrouter.route(\"/github\").get(verifyJWT, privateCache(60), getGithubLeaderboard);\nrouter.route(\"/leetcode\").get(verifyJWT, privateCache(60), getLeetcodeLeaderboard);\n\nexport default router;\n"}},"errors":{"files_not_found":["backend/public/default_avatar.png","backend/public/default_coverimage.jpg","backend/public/temp/.gitkeep","backend/src/job_scarpper/resume.pdf"]},"stats":{"total_files_in_tree":221,"files_in_target_dirs":218,"total_key_files_found":60,"total_key_files_with_content":56,"files_failed":4,"directories_crawled":0}}
